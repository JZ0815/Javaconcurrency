## Chapter 6 LockSupport and Thread Interruption

### 6.1 Thread Interruption Mechanism

#### 6.1.1 Understanding Thread Interruption
In Java, threads should self-terminate rather than being forcibly stopped by external threads. Consequently, deprecated methods like `Thread.stop()`, `Thread.suspend()`, and `Thread.resume()` should never be used.

Key Principles:
- **Cooperative Mechanism**: Interruption serves as a coordination protocol
- **No Immediate Termination**: Requires explicit implementation by developers
- **State Flagging**: `interrupt()` only sets the thread's interruption flag
- **Manual Checking**: Threads must actively verify their interruption status

#### 6.1.2 Interruption API Methods

| Method | Type | Behavior |
|--------|------|----------|
| `void interrupt()` | Instance | Sets interruption flag to true |
| `static boolean interrupted()` | Static | Checks and clears interruption status |
| `boolean isInterrupted()` | Instance | Checks interruption flag without modification |

Key Characteristics:
- `interrupted()` has side effects (clears status)
- Consecutive `interrupted()` calls may return different values
- `isInterrupted()` provides non-destructive status check

### 6.2 Implementing Thread Termination

#### 6.2.1 Volatile Variable Approach
```java
public class InterruptDemo {
    private static volatile boolean isStop = false;

    public static void main(String[] args) {
        new Thread(() -> {
            while(!isStop) {
                System.out.println("Thread executing...");
            }
            System.out.println("Thread terminated via flag");
        }, "t1").start();

        try { TimeUnit.SECONDS.sleep(1); } 
        catch (InterruptedException e) { e.printStackTrace(); }
        
        isStop = true;
    }
}
```

#### 6.2.2 AtomicBoolean Approach
```java
public class StopThreadDemo {
    private final static AtomicBoolean atomicBoolean = new AtomicBoolean(true);

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            while(atomicBoolean.get()) {
                System.out.println("Thread running...");
            }
        }, "t1");
        t1.start();

        try { TimeUnit.SECONDS.sleep(3); } 
        catch (InterruptedException e) { e.printStackTrace(); }
        
        atomicBoolean.set(false);
    }
}
```

#### 6.2.3 Native Interruption Approach
```java
public class NativeInterruptDemo {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            while(!Thread.currentThread().isInterrupted()) {
                System.out.println("Thread active...");
            }
            System.out.println("Thread received interruption signal");
        }, "t1");
        t1.start();

        try { TimeUnit.MILLISECONDS.sleep(5); } 
        catch (InterruptedException e) { e.printStackTrace(); }
        
        t1.interrupt();
    }
}
```

### 6.3 Interruption Behavior Deep Dive

#### 6.3.1 Interruption Scenarios
1. **Active Threads**:
   - Only sets interruption flag
   - Thread continues execution until manually checked

2. **Blocked Threads** (sleep/wait/join):
   - Immediately throws InterruptedException
   - Clears interruption status after exception

#### 6.3.2 Critical Code Example
```java
public class InterruptBehaviorDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i=0; i<300; i++) {
                if(Thread.currentThread().isInterrupted()) {
                    System.out.println("Interruption detected during execution");
                    return;
                }
                System.out.println("Processing item: " + i);
            }
        }, "t1");
        
        t1.start();
        t1.interrupt();
        System.out.println("Initial interrupt status: " + t1.isInterrupted());
        
        TimeUnit.SECONDS.sleep(1);
        System.out.println("Final interrupt status: " + t1.isInterrupted());
    }
}
```

#### 6.3.3 Key Observations
- **Static vs Instance Methods**:
  ```java
  Thread.currentThread().interrupt();
  System.out.println(Thread.interrupted());  // true (then clears)
  System.out.println(Thread.interrupted());  // false
  System.out.println(Thread.currentThread().isInterrupted()); // false
  ```

- **Blocking Operations**:
  ```java
  Thread t2 = new Thread(() -> {
      try {
          TimeUnit.SECONDS.sleep(10);
      } catch (InterruptedException e) {
          System.out.println("Sleep interrupted: " + 
              Thread.currentThread().isInterrupted()); // false
      }
  });
  t2.start();
  t2.interrupt();
  ```

#### 6.3.4 Best Practices Summary
1. Prefer interruption flags over deprecated methods
2. Always handle InterruptedException properly
3. Use `interrupted()` when status clearance is desired
4. For persistent status checks, use `isInterrupted()`
5. Clean up resources in finally blocks when responding to interruptions

### 6.4 LockSupport Fundamentals

#### 6.4.1 Core Concept
LockSupport serves as the foundational building block for creating locks and synchronization classes in Java. It provides thread blocking primitives through two key methods:
- `park()`: Blocks the current thread
- `unpark(Thread)`: Unblocks the specified thread

Key Characteristics:
- Uses a permission-based mechanism (0/1 binary semaphore)
- No synchronization block requirements
- Permits don't accumulate (max value = 1)
- Threads maintain individual permit states

### 6.5 Thread Wait/Notify Mechanisms

#### 6.5.1 Three Approaches Compared

**Object Monitor**
```java
// Requires synchronized block
synchronized(obj) {
    obj.wait();  // Releases monitor
    obj.notify(); // Wakes single thread
}
```

**Condition Interface**
```java
Lock lock = new ReentrantLock();
Condition cond = lock.newCondition();

lock.lock();
try {
    cond.await();    // Releases lock
    cond.signal();   // Wakes single thread
} finally {
    lock.unlock();
}
```

**LockSupport**
```java
// No synchronization required
LockSupport.park();       // Blocks current thread
LockSupport.unpark(t1);   // Unblocks target thread
```

#### 6.5.2 Critical Implementation Rules

**Object Monitor Requirements:**
1. Must be called within synchronized blocks
2. Strict wait-notify sequence required
3. IllegalMonitorStateException if rules violated

**Condition Interface Requirements:**
1. Requires lock acquisition before use
2. Must maintain await-signal sequence
3. IllegalMonitorStateException if misused

**LockSupport Advantages:**
1. No synchronization constraints
2. Permits flexible call ordering
3. Precise thread targeting
4. No exception handling requirements

### 6.6 LockSupport Deep Dive

#### 6.6.1 Core Methods

| Method | Behavior |
|--------|----------|
| `park()` | Blocks current thread if permit unavailable |
| `park(Object blocker)` | Blocks with blocker object for diagnostics |
| `unpark(Thread)` | Provides permit to specified thread |

#### 6.6.2 Usage Patterns

**Basic Operation:**
```java
Thread t1 = new Thread(() -> {
    System.out.println("Thread parking");
    LockSupport.park();
    System.out.println("Thread unparked");
});
t1.start();

TimeUnit.SECONDS.sleep(1);
LockSupport.unpark(t1);  // Can precede park()
```

**Blocker Object:**
```java
Object blocker = new Object();
LockSupport.parkNanos(blocker, TimeUnit.SECONDS.toNanos(2));
```

**Key Features:**
1. **Order Flexibility**: unpark() can precede park()
2. **Precise Control**: Direct thread targeting
3. **No Blocking**: unpark() never blocks
4. **Permit Semantics**: Single-use permits

#### 6.6.3 Comparison Table

| Feature | Object Monitor | Condition | LockSupport |
|---------|---------------|-----------|-------------|
| Sync Required | Yes | Yes | No |
| Call Order | Strict | Strict | Flexible |
| Exception Handling | Required | Required | None |
| Thread Targeting | Broadcast | Selective | Precise |
| Blocking Timeout | Limited support | Supported | Supported |
| Diagnostic Info | Basic | Some | Advanced |

#### 6.6.4 Best Practices
1. Prefer LockSupport for low-level synchronization
2. Use Condition when needing multiple wait sets
3. Reserve Object monitors for legacy compatibility
4. Always document thread coordination protocols
5. Consider parkNanos() for time-bound operations

{pagebreak}
