## Chapter 15 Virtual Thread Basics

#### 15.1 Introduction to Virtual Threads

#### **Why Virtual Threads Matter**

High-concurrency applications often push traditional threading models to their limits. **Synchronous programming**, while intuitive and developer-friendly—with clear control flow, easier debugging, and better readability—struggles under load due to the high cost of thread creation and the risk of thread blocking. On the other hand, **asynchronous programming** offers improved scalability but comes at the cost of increased complexity, reduced readability, and more difficult debugging.

This trade-off between simplicity and performance led to the search for a better model—and that’s where **virtual threads** come in. They offer a compelling middle ground: developers can write code in a synchronous style, while the runtime executes it asynchronously under the hood. This approach preserves clarity while unlocking scalability.


#### **The Evolution of Threading in Java**

The journey of Java’s threading model mirrors this ongoing need for balance between performance and simplicity:

- **Java 1.0** introduced green threads (user-mode threads)
- **Java 1.2+** transitioned to OS-level platform threads
- **Java 19** previewed virtual threads as part of **Project Loom**
- **Java 20** refined the feature with a second preview
- **Java 21** officially integrated virtual threads as a standard feature

Unlike platform threads, which are tied to native OS threads and are resource-intensive, **virtual threads** are lightweight, cheap to create, and ideal for handling massive concurrency. They free developers from the limitations of thread pools and reactive frameworks, enabling a simpler and more scalable model—such as creating a separate thread per HTTP request—without sacrificing performance.

#### **What's New in JDK 24**

The story doesn't end with Java 21. In **JDK 24**, virtual threads gain a critical enhancement: the ability to run **`synchronized` methods and blocks without being pinned to platform threads**. This change is particularly impactful for applications with existing synchronized code, removing a key limitation and making it easier to adopt virtual threads in legacy systems. With this improvement, virtual threads become even more powerful and practical for real-world use cases.

Virtual threads differ significantly from traditional platform threads in terms of resource usage and performance. While platform threads require over 2KB of metadata and a fixed ~1MB stack size, virtual threads are far more lightweight, using only around 200–300 bytes of metadata and a dynamically scalable stack. Context switching is also much faster with virtual threads—measured in nanoseconds compared to the 1–10 microseconds typical of platform threads. Despite these differences, both are still represented by the familiar `Thread` object in Java. This efficiency makes previously impractical designs, like a thread-per-request model, feasible and performant with virtual threads.

Many developers may ask: why not just stick with non-blocking I/O or reactive programming frameworks like WebFlux? While those models offer scalability, they often lead to complex, hard-to-maintain codebases. Virtual threads, by contrast, allow you to write straightforward, blocking-style code without sacrificing scalability or performance. You can continue to use familiar blocking APIs while maintaining clean, readable code. As some developers now say, **"single-threaded style is king."** Benchmark results—such as those from Helidon 4—demonstrate that virtual threads can achieve performance on par with asynchronous frameworks, even under heavy throughput.

#### 15.2 Constructing Virtual Threads

Virtual threads can be created with a high degree of flexibility and ease, using several built-in mechanisms provided by the Java platform. These mechanisms allow you to quickly start lightweight threads, customize their behavior, or create factories for reuse in concurrent applications.

#### Basic Creation Methods

There are two direct ways to create and start a virtual thread immediately:

- **Using `Thread.ofVirtual().start(...)`**  
  This fluent API allows for inline creation and execution of a virtual thread:
  
  ```java
  Thread t = Thread.ofVirtual().start(() -> {
      // task logic
  });
  ```

- **Using `Thread.startVirtualThread(...)`**  
  This utility method offers a concise alternative:
  
  ```java
  Thread t = Thread.startVirtualThread(() -> {
      // task logic
  });
  ```

These methods provide a straightforward way to launch concurrent tasks without the overhead of platform threads, making thread-per-task designs viable even at scale.

#### Using Virtual Thread Factories

For more controlled or repeated creation of threads, you can generate a reusable virtual thread factory:

```java
ThreadFactory factory = Thread.ofVirtual().factory();
Thread t = factory.newThread(() -> {
    // task logic
});
t.start();
```

This approach is ideal for integrating virtual threads into frameworks or existing infrastructure that expects a `ThreadFactory` interface.

#### Thread Builder API: Advanced Configuration

To support more sophisticated use cases, the virtual thread API offers a builder interface that lets you customize thread properties before creation. The builder exposes several configuration options:

| Method                             | Description                          |
|------------------------------------|--------------------------------------|
| `name(String)`                     | Assigns a custom thread name         |
| `daemon(boolean)`                  | Marks the thread as a daemon thread  |
| `priority(int)`                    | Sets thread scheduling priority      |
| `group(ThreadGroup)`              | Assigns the thread to a thread group |
| `stackSize(long)`                  | Suggests a custom stack size         |
| `uncaughtExceptionHandler(...)`    | Sets a handler for uncaught exceptions |
| `inheritInheritableThreadLocals(...)` | Controls inheritance of thread-local values |

In addition, the builder offers three creation modes:

- **`start()`** – Instantly creates and starts the thread  
- **`unstarted()`** – Creates a thread but does not start it  
- **`factory()`** – Returns a `ThreadFactory` based on the builder’s configuration  

This comprehensive API eliminates the need for third-party tools such as Guava’s `ThreadFactoryBuilder`. Developers now have everything they need for fine-grained thread management directly within the Java standard library.

With these tools in hand, constructing and managing virtual threads becomes intuitive, scalable, and adaptable to a wide range of concurrency strategies.


### 15.3 Characteristics of Virtual Threads

Virtual threads are designed to behave as closely as possible to platform threads from a developer’s perspective—while offering dramatically improved scalability under the hood. However, there are several important distinctions and limitations to be aware of when working with them. This section explores the key properties that define how virtual threads behave in Java.

#### 15.3.1 Identifying a Virtual Thread

To determine whether a given thread is virtual, the `Thread` class provides a built-in method:

```java
boolean isVirtual = Thread.currentThread().isVirtual();
```

This allows your application logic or diagnostics tools to branch behavior based on the thread type—virtual or platform. It's especially useful when writing libraries or frameworks that want to remain compatible with both threading models.

#### 15.3.2 Naming Virtual Threads

Just like platform threads, virtual threads can be assigned names. This is helpful for debugging or logging purposes. You can specify a name using the builder API:

```java
Thread t = Thread.ofVirtual().name("my-virtual-thread").start(() -> {
    // task logic
});
```

If no name is provided, the system will assign a default name, such as `VirtualThread-12`.


#### 15.3.3 Daemon Status

By default, **virtual threads are daemon threads**, meaning they do not prevent the JVM from shutting down when the main thread exits. Attempting to explicitly change the daemon status of a virtual thread (e.g., calling `setDaemon(false)`) results in an `IllegalArgumentException`.

```java
Thread t = Thread.startVirtualThread(() -> {});
t.setDaemon(false); // Throws IllegalArgumentException
```

This restriction ensures that virtual threads remain lightweight and do not interfere with JVM shutdown behavior.


#### 15.3.4 Thread Priority

Virtual threads **do not support priority settings**. Calling `setPriority(...)` on a virtual thread has no effect or may throw an exception, depending on the implementation. Internally, all virtual threads are scheduled cooperatively by the JVM and not via OS-level prioritization.

This design decision simplifies the scheduler and avoids complexity that arises from trying to map thread priorities across millions of lightweight threads.


#### 15.3.5 Thread Groups

Virtual threads **do belong to a thread group**, but unlike platform threads, they are not organized for coordination or management via this grouping. The thread group for a virtual thread is mainly retained for compatibility reasons.

You can inspect the group using:

```java
ThreadGroup group = Thread.currentThread().getThreadGroup();
```

However, for most practical purposes, thread groups play a minimal role in modern Java concurrency—especially with virtual threads.


Virtual threads preserve much of the same API surface as platform threads, making them easy to adopt. However, their limitations in areas like priority, daemon status, and thread groups reflect a design trade-off to favor performance, predictability, and scale. Understanding these characteristics helps developers write code that fully leverages the benefits of virtual threads without running into unexpected behavior.


### 15.4 Using Virtual Threads

Virtual threads aren't just a language-level feature—they integrate seamlessly into the Java concurrency ecosystem. This section explores how to use virtual threads in real-world applications, especially via the familiar `ExecutorService` interface. You'll learn how Java enables a **thread-per-task** model without the traditional overhead, and how the platform supports clean lifecycle management of virtual threads behind the scenes.


#### 15.4.1 Leveraging `ExecutorService`

To enable virtual threads at scale, Java provides a new executor:  
```java
Executors.newVirtualThreadPerTaskExecutor();
```

This factory method returns an `ExecutorService` implementation where each task is executed in its **own virtual thread**. This model is highly scalable and aligns with modern application architectures where handling thousands or even millions of concurrent tasks is the norm.

Because virtual threads are lightweight, using a **thread-per-task** strategy becomes viable and efficient—unlike with traditional platform threads, which would exhaust system resources quickly.


#### 15.4.2 Anatomy of `newVirtualThreadPerTaskExecutor()`

Under the hood, this method is implemented like so:

```java
public static ExecutorService newVirtualThreadPerTaskExecutor() {
    ThreadFactory factory = Thread.ofVirtual().factory();
    return newThreadPerTaskExecutor(factory);
}
```

It creates a new `ThreadFactory` for virtual threads and passes it to a custom `ThreadPerTaskExecutor`, a lightweight executor that starts a new thread per task.


#### 15.4.3 How `execute()` Works

Here’s how a submitted task is handled when `execute()` is called:

```java
private Thread start(Runnable task) {
    Objects.requireNonNull(task);
    ensureNotShutdown();
    Thread thread = newThread(new TaskRunner(this, task));
    start(thread);
    return thread;
}
```

The task is wrapped in a `TaskRunner`, which handles execution and signals task completion:

```java
private static class TaskRunner implements Runnable {
    final ThreadPerTaskExecutor executor;
    final Runnable task;

    TaskRunner(ThreadPerTaskExecutor executor, Runnable task) {
        this.executor = executor;
        this.task = task;
    }

    @Override
    public void run() {
        try {
            task.run();
        } finally {
            executor.taskComplete(Thread.currentThread());
        }
    }
}
```

This ensures proper cleanup and lifecycle tracking, without requiring the developer to manually manage the threads.


#### 15.4.4 How `submit()` Works

The `submit()` method follows a similar pattern, but it returns a `Future` for asynchronous result handling:

```java
public <T> Future<T> submit(Callable<T> task) {
    Objects.requireNonNull(task);
    ensureNotShutdown();
    var future = new ThreadBoundFuture<T>(this, task);
    Thread thread = future.thread();
    start(thread);
    return future;
}
```

Internally, it uses a `ThreadBoundFuture`, which ties a virtual thread to a future task:

```java
private static class ThreadBoundFuture<T> extends FutureTask<T> implements Runnable {
    final ThreadPerTaskExecutor executor;
    final Thread thread;

    ThreadBoundFuture(ThreadPerTaskExecutor executor, Callable<T> task) {
        super(task);
        this.executor = executor;
        this.thread = executor.newThread(this);
    }

    Thread thread() {
        return thread;
    }

    @Override
    protected void done() {
        executor.taskComplete(thread);
    }
}
```

This structure ensures clean shutdown behavior and proper task accounting.


#### 15.4.5 Practical Implications

- **Ease of Use**: Virtual-thread-backed executors work just like traditional ones, requiring no major rewrites.
- **Scalability**: You can now afford to assign one thread per task—even for millions of tasks.
- **Compatibility**: Works with existing concurrency frameworks (`ExecutorService`, `Future`, etc.).

#### 15.4.6 Conclusion

The introduction of `newVirtualThreadPerTaskExecutor()` redefines how we think about thread management in Java. Instead of building complex thread pools, developers can embrace a **"threads-as-tasks"** model—writing cleaner, more maintainable code without compromising on performance.

Virtual threads, combined with well-integrated executors, make high-concurrency Java applications simpler, faster, and more elegant than ever before.


### 15.5 Comparing Virtual Threads with Platform Threads

One of the most compelling use cases for virtual threads is how dramatically they outperform traditional platform threads in terms of scalability and resource consumption—especially in thread-per-task workloads.

This section walks you through a practical comparison using sample code. We’ll use two executors:

- `Executors.newFixedThreadPool(...)`: traditional platform threads.
- `Executors.newVirtualThreadPerTaskExecutor()`: virtual threads.

We’ll submit thousands of blocking tasks to each and observe how they behave.


#### 15.5.1 Sample Code: Platform Threads

```java
try (var executor = Executors.newFixedThreadPool(100)) {
    IntStream.range(0, 10_000).forEach(i -> {
        executor.submit(() -> {
            Thread.sleep(1000);
            return i;
        });
    });
}
```

In this version:

- We use a **fixed thread pool** with 100 platform threads.
- Each task **sleeps for 1 second**, simulating blocking I/O.
- Submitting 10,000 tasks causes queuing: only 100 run at a time, so it takes about **100 seconds** to complete.


#### 15.5.2 Sample Code: Virtual Threads

```java
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 10_000).forEach(i -> {
        executor.submit(() -> {
            Thread.sleep(1000);
            return i;
        });
    });
}
```

Here, we use the **virtual thread executor**:

- Each task runs in its own **virtual thread**.
- 10,000 virtual threads are created effortlessly.
- All tasks can sleep concurrently without blocking physical threads.
- Completion time is **close to 1 second**, not 100!


#### 15.5.3 Performance and Resource Comparison

| Aspect                  | Platform Threads                          | Virtual Threads                            |
|------------------------|-------------------------------------------|--------------------------------------------|
| Executor               | `newFixedThreadPool(100)`                 | `newVirtualThreadPerTaskExecutor()`        |
| Thread Type            | OS-level (Platform)                       | Lightweight (User-mode / Virtual)          |
| Max Parallelism        | Limited by pool size                      | One thread per task                         |
| Blocking Overhead      | High (uses real threads)                  | Minimal (threads are parked efficiently)   |
| Task Throughput        | Low under blocking                        | Very high—even with blocking               |
| Memory Usage per Task  | ~1MB stack per thread                     | ~200-300 bytes per thread                  |
| Completion Time (10k tasks) | ~100 seconds                        | ~1 second                                   |


#### 15.5.4 Key Insights

- Virtual threads **scale naturally** for I/O-bound tasks where threads block frequently.
- You **don’t need to tune pool sizes**—just submit your tasks.
- Blocking code becomes **scalable again**, enabling simpler and more maintainable designs.


#### 15.5.5 When to Use Which?

| Use Case                        | Recommendation         |
|----------------------------------|------------------------|
| CPU-bound computation           | Platform threads (explicit pools) |
| I/O-bound with blocking APIs    | Virtual threads         |
| Mixed workloads                 | Consider hybrid approaches or benchmarking |
| Legacy code requiring blocking  | Virtual threads for painless migration |


Virtual threads bring a **revolutionary change** in how Java applications handle concurrency. By allowing thousands (or millions) of concurrent tasks without platform thread overhead, they redefine what’s possible in server-side programming.

Whether you're writing a web server, batch processor, or I/O-heavy application—**you can now keep your blocking code and still scale**.

### 15.6 Virtual Threads and Thread Local

#### **15.6.1 Understanding Thread Local**

**ThreadLocal** is a mechanism in Java that allows each thread to store its own independent copy of a value. This ensures that each thread reads and updates its own value, making it thread-safe without needing synchronization. Common use cases for **ThreadLocal** include:

- **Thread-Safe Objects**: Converting thread-unsafe objects into thread-safe versions by giving each thread its own instance of the object.
- **Expensive Object Creation**: Caching objects that are costly to create, ensuring that each thread reuses the same object.
- **Global-Like Variables**: Providing a convenient way to share values across various parts of an application without explicitly passing data around.

While ThreadLocal is a powerful tool in many situations, its use in applications with **virtual threads** (which are lightweight and can scale to a high number) introduces some performance concerns. Virtual threads, by design, allow for the creation of millions of threads, and each thread potentially requires its own thread-local storage, which can lead to high memory consumption.


#### **15.6.2 Potential Issues with Thread Local and Virtual Threads**

When **ThreadLocal** is used with virtual threads, there are some significant challenges to be aware of:

- **Excessive Number of Virtual Threads**: Virtual threads are designed to be lightweight, and applications may create large numbers of them. However, each virtual thread that uses **ThreadLocal** needs its own storage, which can quickly accumulate and consume substantial memory when working with a large number of threads.
- **Memory Consumption**: Although virtual threads themselves are lightweight, the use of **ThreadLocal** can counteract this advantage. Each thread still needs memory for its thread-local data, which can result in high memory usage across many virtual threads.

A better approach in such scenarios is to use **Scoped Value** (introduced in Java 21+), which provides a more efficient, structured way of sharing data across virtual threads without the memory overhead of **ThreadLocal**.


#### **15.6.3 Using ThreadLocal with InheritableThreadLocal**

Java offers two types of thread-local storage: **ThreadLocal** and **InheritableThreadLocal**.

- **ThreadLocal**: Each thread has its own independent value, and it is not inherited by child threads.
- **InheritableThreadLocal**: The value can be inherited by child threads, making it useful for passing data down the thread hierarchy.

Here’s an example that demonstrates the behavior of `InheritableThreadLocal` when used with virtual threads:

```java
var inheritableThreadLocal = new InheritableThreadLocal<Integer>();
Thread.ofVirtual()
    .name("parent")
    .start(() -> {
        inheritableThreadLocal.set(300);
        try {
            Thread.ofVirtual()
                .name("child")
                .inheritInheritableThreadLocals(false)
                .start(() -> System.out.println(
                    "Value is " + inheritableThreadLocal.get())) // null
                .join();
        } catch (InterruptedException e) {
            // ignore
        }
    }).join();
```

In this example, the `child` thread does not inherit the value from the `parent` thread because we explicitly set `inheritInheritableThreadLocals(false)`. This ensures that the child thread does not share the parent’s thread-local data.


#### **15.6.4 Debugging Thread Locals in Virtual Threads**

When working with **ThreadLocal** in virtual threads, debugging can be more challenging due to the lightweight nature of virtual threads and the potential for large numbers of them. To help diagnose issues related to **ThreadLocal** usage, you can enable tracing by setting the `jdk.traceVirtualThreadLocals` option.

**To enable tracing**:

```bash
-Djdk.traceVirtualThreadLocals=true
```

This allows you to trace the setting and getting of **ThreadLocal** values across virtual threads, which can help identify memory leaks or misuse.

**Sample Stack Trace**:

```
Hello  
VirtualThread[#25]/runnable@ForkJoinPool-1-worker-1  
java.base/java.lang.ThreadLocal.set(ThreadLocal.java:253)  
io.vividcode.course.virtualthreads.ThreadLocals.Lambda$inheritableThreadLocal$3(ThreadLocals.java:14)  
java.base/java.lang.VirtualThread.run(VirtualThread.java:309)
```

The trace shows where **ThreadLocal** values are being set or accessed within virtual threads, helping to track down potential issues.


#### **15.6.5 ThreadLocal as Object Cache**

One of the common patterns using **ThreadLocal** is for **object caching**, where an expensive object (such as a deserialized JSON object) is cached in a **ThreadLocal** variable, ensuring each thread has its own copy. Libraries like **Jackson** have used this pattern to improve performance by avoiding the repeated creation of objects. However, this approach doesn’t scale well with **virtual threads**.

- **Scalability Issues**: The lightweight nature of virtual threads allows for the creation of millions of threads. If each of these threads uses a **ThreadLocal** for caching, the total memory usage can increase significantly.
- **Anti-Pattern**: Using **ThreadLocal** for caching in virtual threads is considered an anti-pattern because it negates the advantages of virtual threads, especially in high-concurrency scenarios. As a result, this pattern should be avoided in applications that use virtual threads.

Instead of using **ThreadLocal** for caching, it’s recommended to use more efficient, scalable solutions like **Scoped Value**, which provides structured and efficient sharing of data across virtual threads.


#### **15.6.6 Key Takeaways**

- **Thread Local Challenges**: Using **ThreadLocal** with virtual threads can lead to high memory usage due to the large number of threads in high-concurrency applications. It’s best to avoid **ThreadLocal** for caching or other memory-heavy tasks in these scenarios.
- **Scoped Value**: For more efficient, structured data sharing between virtual threads, consider using **Scoped Value**, introduced in Java 21+, as a better alternative to **ThreadLocal**.
- **Debugging**: Enable the `jdk.traceVirtualThreadLocals` option to trace **ThreadLocal** usage in virtual threads and help identify memory leaks or misuse.
- **Anti-Pattern**: Avoid using **ThreadLocal** for caching in virtual threads, as it introduces scalability and memory usage issues, and prefer more scalable solutions for high-concurrency environments.
{pagebreak}
