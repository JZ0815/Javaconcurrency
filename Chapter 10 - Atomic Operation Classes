## Chapter 10 High-Performance Atomic Operations: From Basics to LongAdder

### **10.1 Atomic Classes in Java**  

#### **10.1.1 Classification of Atomic Classes**  

1. **AtomicBoolean** – A thread-safe boolean value that supports atomic updates.  
2. **AtomicInteger** – An atomic integer with CAS-based operations like `incrementAndGet()`.  
3. **AtomicIntegerArray** – An array of integers where each element can be updated atomically.  
4. **AtomicIntegerFieldUpdater** – A reflection-based utility to atomically update volatile int fields.  
5. **AtomicLong** – Similar to `AtomicInteger`, but for long values.  
6. **AtomicLongArray** – An array of longs with atomic element updates.  
7. **AtomicLongFieldUpdater** – Allows atomic updates to volatile long fields using reflection.  
8. **AtomicMarkableReference** – An atomic reference with an additional boolean "mark" bit for state tracking.  
9. **AtomicReference** – A generic atomic reference for custom objects (e.g., `AtomicReference<User>`).  
10. **AtomicReferenceArray** – An array of object references with atomic updates.  
11. **AtomicReferenceFieldUpdater** – Reflection-based atomic updates for volatile reference fields.  
12. **AtomicStampedReference** – An atomic reference with a version stamp to solve the ABA problem.  
13. **DoubleAccumulator** – A high-performance accumulator for double values using supplied functions.  
14. **DoubleAdder** – Optimized for high contention, providing atomic addition for doubles.  
15. **LongAccumulator** – Similar to `DoubleAccumulator`, but for long values with custom operations.  
16. **LongAdder** – A low-contention alternative to `AtomicLong` for frequent increments.  

**Key Takeaways:**  
- **Primitive atomics** (`AtomicInteger`, `AtomicLong`) optimize single-value updates.  
- **Array atomics** (`AtomicIntegerArray`, `AtomicReferenceArray`) enable fine-grained concurrent array modifications.  
- **Field updaters** (e.g., `AtomicIntegerFieldUpdater`) provide atomicity without wrapping objects.  
- **Stamped references** (`AtomicStampedReference`) prevent ABA issues in lock-free algorithms.  
- **Adders/Accumulators** (`LongAdder`, `DoubleAccumulator`) maximize throughput under high contention.  

These classes form the backbone of **non-blocking algorithms** in Java, eliminating locks while ensuring thread safety.
Here's the rewritten and expanded version of sections 10.2 to 10.4 in English:

### 10.2 Classification of Atomic Classes

#### 10.2.1 Primitive Type Atomic Classes
These classes provide atomic operations for basic data types:
- **AtomicInteger**: Thread-safe int operations
- **AtomicBoolean**: Atomic boolean value updates
- **AtomicLong**: Atomic operations on long values

**Key APIs:**
- `get()`: Returns current value
- `getAndSet(newValue)`: Gets current value and updates
- `getAndIncrement()`: Atomic increment
- `getAndDecrement()`: Atomic decrement
- `getAndAdd(delta)`: Adds delta to current value
- `compareAndSet(expect, update)`: Updates only if current value matches expected

**Example Usage:**
```java
class Counter {
    private AtomicInteger count = new AtomicInteger();
    
    public void increment() {
        count.incrementAndGet();
    }
}
```

#### 10.2.2 Array Type Atomic Classes
Atomic versions of arrays:
- **AtomicIntegerArray**: Atomic int array operations
- **AtomicLongArray**: Atomic long array operations
- **AtomicReferenceArray**: Atomic object reference array operations

**Example:**
```java
AtomicIntegerArray array = new AtomicIntegerArray(10);
array.getAndIncrement(0); // Atomically increments first element
```

#### 10.2.3 Reference Type Atomic Classes
For atomic object reference operations:
- **AtomicReference**: Basic atomic reference
- **AtomicStampedReference**: Reference with version stamp to solve ABA problem
- **AtomicMarkableReference**: Reference with boolean mark flag

**Spin Lock Example:**
```java
class SpinLock {
    private AtomicReference<Thread> owner = new AtomicReference<>();
    
    public void lock() {
        while (!owner.compareAndSet(null, Thread.currentThread())) {}
    }
    
    public void unlock() {
        owner.compareAndSet(Thread.currentThread(), null);
    }
}
```

**ABA Problem Solution:**
```java
AtomicStampedReference<Integer> ref = new AtomicStampedReference<>(100, 0);

// Thread 1:
int stamp = ref.getStamp();
ref.compareAndSet(100, 101, stamp, stamp+1);

// Thread 2 will fail if stamp changed
```

#### 10.2.4 Field Updater Atomic Classes
For atomic field updates:
- **AtomicIntegerFieldUpdater**: Updates volatile int fields
- **AtomicLongFieldUpdater**: Updates volatile long fields
- **AtomicReferenceFieldUpdater**: Updates volatile reference fields

**Requirements:**
- Fields must be `public volatile`
- Must create updater with static `newUpdater()` method

**Example:**
```java
class BankAccount {
    public volatile int balance;
    private static final AtomicIntegerFieldUpdater<BankAccount> updater =
        AtomicIntegerFieldUpdater.newUpdater(BankAccount.class, "balance");
    
    public void deposit(int amount) {
        updater.addAndGet(this, amount);
    }
}
```

#### 10.2.5 High-Performance Accumulators
For high-contention scenarios:
- **LongAdder**: Optimized for frequent increments
- **LongAccumulator**: Custom accumulation operations
- **DoubleAdder/DoubleAccumulator**: Double versions

**Performance Comparison:**
```java
LongAdder adder = new LongAdder();
adder.increment(); // Faster than AtomicLong under contention

LongAccumulator accumulator = new LongAccumulator(Long::sum, 0);
accumulator.accumulate(5);
```

### 10.3 Implementation Analysis

#### 10.3.1 LongAdder Architecture
- Inherits from **Striped64**
- Uses **cells array** to distribute contention
- Falls back to **base value** when no contention

**Key Components:**
- `base`: Main value for low contention
- `cells[]`: Array of counters for high contention
- `cellsBusy`: Spinlock for resizing cells

#### 10.3.2 Why LongAdder is Faster
- **Hotspot dispersion**: Contention distributed across cells
- **Lower CAS failures**: Threads work on separate cells
- **Final sum**: Combines base + all cell values

### 10.4 Practical Applications

#### 10.4.1 Use Cases
- **Counting**: High-frequency counters (e.g., metrics)
- **Statistics**: Performance monitoring
- **Non-blocking algorithms**: Concurrent data structures

#### 10.4.2 Selection Guide
- **Low contention**: AtomicInteger/AtomicLong
- **High contention**: LongAdder/DoubleAdder
- **Custom operations**: LongAccumulator
- **Object references**: AtomicReference with versioning

**Performance Characteristics:**
| Operation | AtomicLong | LongAdder |
|-----------|------------|-----------|
| Increment | 50ns | 15ns |
| High contention | Poor | Excellent |
| Read | Fast | Slower (sum()) |
| Memory | Low | Higher |

This organization maintains technical accuracy while improving readability and practical applicability for Java developers working with concurrent programming.
### **10.5 LongAdder Implementation Deep Dive**  

#### **10.5.1 Mathematical Representation**  
LongAdder uses two key components to optimize performance under contention:  
1. **Base Variable (`base`)**  
   - Used in **non-contended** cases (direct CAS updates).  
   - Acts as the primary counter when no thread collisions occur.  

2. **Cell Array (`Cell[]`)**  
   - Activated under **contention** to distribute updates across multiple slots.  
   - Each thread hashes to a specific cell (reducing CAS collisions).  

#### **10.5.2 Core Workflow of `increment()`**  
1. **No Contention**: Updates `base` directly via CAS.  
2. **Initial Contention**: Creates the `Cell[]` array (default length 2).  
3. **High Contention**: Expands `Cell[]` dynamically (powers of 2).  

**Key Steps in `longAccumulate()`:**  
- **Thread Hashing**: Each thread gets a unique `probe` hash to map to a cell.  
- **Three Cases**:  
  - **Case 1**: `Cell[]` exists → Update the hashed cell.  
  - **Case 2**: `Cell[]` uninitialized → Acquire lock and initialize.  
  - **Case 3**: `Cell[]` busy → Fall back to CAS on `base`.  

**Example Cell Initialization:**  
```java  
Cell[] rs = new Cell[2];  
rs[threadProbe & 1] = new Cell(1); // Hash-based slot assignment  
```  

#### **10.5.3 Sum Calculation**  
- **Non-Atomic Sum**: Combines `base` + all `Cell[]` values.  
- **Weak Consistency**:  
  - No locks during summation → may miss concurrent updates.  
  - **Trade-off**: High throughput at the cost of temporary inaccuracy.  


### **10.6 LongAdder vs. AtomicLong**  

#### **10.6.1 AtomicLong Limitations**  
- **Single Hotspot**: All threads CAS a single `value` → high contention.  
- **Performance Drop**: Under high concurrency, failed CAS spins consume CPU.  
- **Use Case**: Low-concurrency scenarios requiring **strict accuracy**.  

#### **10.6.2 LongAdder Advantages**  
- **Distributed Hotspots**: Updates spread across `Cell[]` + `base`.  
- **Scalability**: Throughput scales with cores (no spinning bottleneck).  
- **Use Case**: High-concurrency counts (e.g., metrics) where **approximate results suffice**.  

#### **10.6.3 Performance Comparison**  
| Metric          | AtomicLong       | LongAdder         |  
|-----------------|------------------|-------------------|  
| **Contention**  | High (CAS spins) | Low (Cell hashing) |  
| **Accuracy**    | Strongly consistent | Eventually consistent |  
| **Throughput**  | Poor under load  | High scalability  |  

**Benchmark Example**:  
- **AtomicLong**: 50 threads → ~50M ops/sec (CPU-bound spinning).  
- **LongAdder**: 50 threads → ~500M ops/sec (linear scaling).  

#### **10.6.4 When to Use Which?**  
- **AtomicLong**:  
  - Banking systems (e.g., account balances requiring exact values).  
  - Low-concurrency locks or flags.  
- **LongAdder**:  
  - Click counters, metrics (e.g., website visits).  
  - High-throughput analytics (precision not critical).  

**Trade-off Summary**:  
- **AtomicLong** = Accuracy + Low Concurrency.  
- **LongAdder** = Throughput + High Concurrency.  


### **Key Takeaways**  
1. **LongAdder’s Design**:  
   - **Space-for-time**: `Cell[]` reduces CAS collisions.  
   - **Dynamic resizing**: Balances memory and performance.  
2. **Sum Inaccuracy**:  
   - Unavoidable trade-off for lock-free reads.  
   - Mitigate by calling `sum()` during low activity.  
3. **Java’s Evolution**:  
   - From `AtomicLong` (JDK 1.5) → `LongAdder` (JDK 1.8) for modern multicore systems.  

For deep dives, refer to [Java 8 Performance: LongAdder vs AtomicLong](http://blog.palominolabs.com/2014/02/10/java-8-performance-improvements-longadder-vs-atomiclong/).
{pagebreak}