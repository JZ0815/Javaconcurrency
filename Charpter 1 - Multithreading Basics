## Charpter 1 - Multithreading Basics

#### 1.1 Processes and Threads
A process is an instance of a program that is being executed. It involves the program code and its current activity, such as its program counter, registers, and variables. From the operating system’s perspective, a process is the fundamental unit for resource allocation and scheduling. It forms the foundation of the system's architecture.

In early computer systems designed around processes, a process was the main unit of execution. As computer systems evolved and became more advanced, modern systems have shifted toward thread-based architectures. In such systems, a process acts more like a container that holds one or more threads.

To put it another way, while a program is simply a static set of instructions and data organized in a particular way, a process represents the actual execution of that program. It is the living, active version of a program in motion.

A thread, on the other hand, is the smallest unit of CPU execution that can be scheduled and managed by the operating system. Each thread exists within a process and is responsible for carrying out the actual execution of code. You can think of a thread as a single sequence of instructions, or a single flow of control, within a process.

A single process can contain multiple threads, all of which share the same memory and system resources but can perform different tasks in parallel. For example, in a web browser, one thread might handle user input, another might handle network communications, and yet another might render the page — all within the same process.

Threads enable concurrent execution within a process, helping to improve the efficiency and responsiveness of applications, especially on multi-core processors.

#### 1.2 Thread States

In Java, threads are an essential part of concurrent programming. Understanding the life cycle of a thread helps developers write robust and efficient multithreaded applications. Java provides a well-defined set of thread states through the `java.lang.Thread.State` enum, which outlines the various stages a thread may occupy during its life.

Below is the declaration of the `State` enum from the `Thread` class:

```java
public enum State {
    NEW,           // Thread has been created but not started
    RUNNABLE,      // Thread is running or ready to run
    BLOCKED,       // Thread is blocked waiting for a monitor lock
    WAITING,       // Thread is waiting indefinitely for another thread's action
    TIMED_WAITING, // Thread is waiting for a limited time
    TERMINATED     // Thread has finished execution
}
```

Let’s walk through each of these states in greater detail:

#### NEW

This is the initial state of a thread when it has been instantiated but has **not yet started**. At this stage, the thread object exists, but it is not yet considered a “live” thread in the JVM.

- **Code Example**:
  ```java
  Thread t = new Thread(() -> System.out.println("Running"));
  // t is in NEW state
  ```

- **Transition**: A thread moves from `NEW` to `RUNNABLE` when the `start()` method is invoked.

#### RUNNABLE

In this state, the thread is considered **ready to run** and may actually be running. The distinction here is subtle but important: a thread in `RUNNABLE` might be actively executing **or** simply waiting in the run queue for CPU time.

- **Example**: After calling `t.start()`, the thread enters the `RUNNABLE` state. It stays here until it's either blocked, waiting, or terminated.

- **Note**: Internally, the JVM relies on the operating system's thread scheduler to allocate CPU time to `RUNNABLE` threads.

#### BLOCKED

A thread is in the `BLOCKED` state when it is waiting to acquire a **monitor lock** (used in `synchronized` blocks or methods) that is currently held by another thread. This typically happens when threads are competing for access to shared resources.

- **Scenario**:
  ```java
  synchronized (lock) {
      // thread holds lock
  }
  // another thread trying to enter synchronized(lock) is BLOCKED
  ```

- **Important Distinction**: Unlike `WAITING`, `BLOCKED` threads are not waiting for a signal—they are waiting for a lock.

#### WAITING

In this state, a thread is waiting **indefinitely** for another thread to perform a particular action. For example, a thread might be waiting for another thread to call `notify()` or `join()`.

- **Common Methods That Cause This**:
  - `Object.wait()` (without timeout)
  - `Thread.join()` (on another thread that hasn’t finished)
  - `LockSupport.park()`

- **Behavior**: The thread will remain in `WAITING` until it's explicitly signaled to resume.

#### TIMED_WAITING

This state is similar to `WAITING`, but with a timeout. The thread will return to `RUNNABLE` either after the specified time has passed or if it's notified prematurely.

- **Common Examples**:
  - `Thread.sleep(milliseconds)`
  - `Object.wait(timeout)`
  - `Thread.join(timeout)`
  - `LockSupport.parkNanos()` or `parkUntil()`

- **Practical Use Case**: Often used when threads poll for conditions or back off for a while before retrying.

#### TERMINATED

This is the final state of a thread. A thread enters `TERMINATED` when its `run()` method finishes execution—either by returning normally or due to an unhandled exception.

- **Lifecycle Completion**:
  - Thread completes its task and exits.
  - If an exception is thrown and not caught, the thread also ends.

- **Check Example**:
  ```java
  if (thread.getState() == Thread.State.TERMINATED) {
      System.out.println("Thread has finished.");
  }
  ```

### Thread Lifecycle Transitions

Here's a simplified view of how threads typically transition between states:

```
NEW → RUNNABLE → [RUNNING]
      ↓          ↘
   BLOCKED      WAITING
                 ↘
             TIMED_WAITING
                   ↓
              TERMINATED
```

- Transitions between `RUNNABLE`, `WAITING`, `BLOCKED`, and `TIMED_WAITING` occur dynamically during the thread's execution, often depending on synchronization logic, thread scheduling, or inter-thread communication.

### Summary of `Thread.State`:

| State           | Description                                                      |
|----------------|------------------------------------------------------------------|
| `NEW`           | Thread has been created but not started                         |
| `RUNNABLE`      | Thread is ready to run or currently executing                   |
| `BLOCKED`       | Waiting to acquire a lock held by another thread                |
| `WAITING`       | Waiting indefinitely for another thread's action                |
| `TIMED_WAITING` | Waiting for a limited amount of time                            |
| `TERMINATED`    | Execution has completed, either normally or through exception   |


** A thread cannot be started more than once. If the start() method is called a second time on the same thread, it will throw an IllegalThreadStateException, which is a runtime exception. Attempting to start a thread multiple times is considered a programming error. Even if the thread has already terminated or is in any state other than NEW, it cannot be restarted.In Java, a thread cannot be started more than once. If the start() method is called a second time on the same thread, it will throw an IllegalThreadStateException, which is a runtime exception. Attempting to start a thread multiple times is considered a programming error. Even if the thread has already terminated or is in any state other than NEW, it cannot be restarted.**

This structured understanding of thread states is foundational to writing safe, concurrent Java applications. In real-world systems, careful state management is key to avoiding deadlocks, race conditions, and performance bottlenecks.


### 1.3 How Many Threads Should You Create?

Determining the optimal number of threads depends heavily on the specific use case of multithreading in your application. In most real-world scenarios, programs involve both CPU computations and I/O operations interleaved together. Since I/O operations (such as file access or network calls) are significantly slower than CPU computations, the CPU often remains idle waiting for I/O to complete. This kind of workload is known as **I/O-bound**. On the other hand, if a program spends most of its time performing pure computation, it is considered **CPU-bound**.

The strategies for choosing the optimal number of threads differ between these two types of workloads. Let's examine each in detail.

#### 1.3.1 CPU-bound Workloads

In a CPU-bound scenario, the primary goal of multithreading is to maximize CPU core utilization. For example, on a system with 4 CPU cores, ideally, you only need **4 threads**, one per core. Creating more threads than the number of cores can lead to frequent context switching, which adds overhead and degrades performance rather than improving it.

Therefore, for CPU-intensive tasks, the rule of thumb is:

**Optimal thread count = Number of CPU cores**

However, in practice, it is often recommended to use:

**Thread count = Number of CPU cores + 1**

This extra thread acts as a buffer in case one thread gets temporarily blocked (e.g., due to a page fault or minor delay), ensuring that the CPU is still fully utilized.

#### 1.3.2 I/O-bound Workloads

For I/O-bound applications, the CPU is frequently idle while waiting for I/O operations to complete. Therefore, we can create more threads to better utilize CPU time during these idle periods.

For instance, consider a program where the time spent on CPU and I/O operations is in a 1:1 ratio. In this case, **2 threads** would be optimal. If the ratio is 1:2 (CPU time : I/O time), the optimal number of threads becomes **3**.

Why? Because when one thread (say, Thread A) is waiting for I/O, the CPU can switch to Threads B and C to perform computation. By the time the CPU cycles back to Thread A, its I/O operation has completed, and it’s ready to compute again. This ensures that **both the CPU and I/O devices are used to their full capacity**.

This concept leads us to the following formula for single-core systems:

**Optimal thread count = 1 + (I/O time / CPU time)**

Let’s define:

`R = I/O time / CPU time`

Then, when Thread A is blocked doing I/O, the CPU works on `R` other threads performing computation. This maximizes CPU utilization.

#### 1.3.3 Extending to Multi-Core Systems

For multi-core systems, we simply scale the above formula based on the number of cores:

 **Optimal thread count = Number of CPU cores × [1 + (I/O time / CPU time)]**

This formula provides a theoretical guideline for choosing the right number of threads to balance CPU and I/O workloads efficiently.

### Chapter 1.4: Why Are Local Variables Thread-Safe in Java?

One of the foundational concerns in concurrent programming is **data sharing**—when multiple threads access and modify the same data, **race conditions** and other concurrency problems can arise. In Java, it's frequently emphasized that shared variables need to be properly synchronized to ensure thread safety. But what about *local variables* inside a method? Are they shared? Can they cause data races?

Let’s unpack this question through a deeper understanding of **stack and heap memory**, **method execution**, and **thread architecture**.


#### 1.4.1 Are All Variables Shared in Java?

Not all variables in Java are shared between threads. While instance fields or static fields can be accessed by multiple threads (and thus may require synchronization), **local variables defined inside a method are not shared**. Surprisingly, some developers still add synchronization to local variables, misunderstanding their memory behavior.

Consider the following method that computes the Fibonacci sequence:

```java
int[] fibonacci(int n) {
  int[] r = new int[n];
  r[0] = r[1] = 1;
  for (int i = 2; i < n; i++) {
    r[i] = r[i - 2] + r[i - 1];
  }
  return r;
}
```

At first glance, you might suspect that if multiple threads call `fibonacci()` at the same time, they might compete over access to the `r` array. But that’s not the case.


#### 1.4.2 What Happens During Method Execution?

To understand this, let’s shift our perspective to how the CPU sees method execution.

At the CPU level, there is no concept of "method"—only **instructions**. Compilers transform high-level methods into low-level instructions. Consider this snippet:

```java
int a = 7;
int[] b = fibonacci(a);
int[] c = b;
```

When executing `fibonacci(a)`, the CPU needs:
1. The **address of the method's code** to jump to.
2. A place to **store the return address**, so it can resume after the method finishes.
3. Memory space for the **arguments and local variables** of the method.

All of this is managed through a **call stack**, a special memory area supported by the CPU’s **stack pointer register**.


#### 1.4.3 The Stack: Home of Local Variables

Each time a method is called, a new **stack frame** is created and pushed onto the thread's call stack. This frame holds:
- Parameters passed to the method.
- Return address (where to resume after method finishes).
- Local variables.

When the method returns, the frame is popped from the stack, and the local variables are discarded.

Importantly, the **stack is thread-private**. Each thread in Java has its **own stack**, completely isolated from others. This architecture is what makes local variables inherently **thread-safe**—they are **never shared** between threads.

If two threads simultaneously call `fibonacci(10)`, each gets its **own array `r`**, its **own set of variables**, and operates on its **own stack frame**.

**Key Insight**: No shared memory means no data race. Without shared state, there's nothing to synchronize.

#### 1.4.4 Heap vs Stack

Java developers often learn early on that:
- **Primitive local variables** and **references to objects** are stored in the **stack**.
- The **objects themselves**, created via `new`, are stored in the **heap**.

But this can cause confusion. Even though `r` is a reference to a heap object (an array), each thread has its **own reference**, stored in **its own stack**. So the object itself, even though on the heap, is **not shared**, as long as the reference isn't passed outside the thread.

Only when a reference is stored in a **shared field** (like a class member or static variable) do we need to consider concurrency risks.


#### 1.4.5 Thread-Stack Relationship

Here’s the mental model:
- Each thread has **one call stack**.
- Each method call creates a **new frame** on that stack.
- Local variables are allocated **within the frame**.
- When the method returns, the frame (and its variables) are removed.

Since stacks are **per-thread**, local variables are **inaccessible** to other threads. This model guarantees that local variables are **thread-confined**.


#### 1.4.6 Thread Confinement: A Concurrency Pattern

This design principle—restricting data access to a single thread—is known as **thread confinement**. It's a key concurrency strategy that ensures thread safety **without synchronization**.

Java libraries often use this technique. A good example is JDBC `Connection` objects. They aren’t thread-safe, but **connection pools ensure** a `Connection` is used by **only one thread at a time**, effectively applying thread confinement to avoid data races.


#### 1.4.7 Summary

- **Method-local variables are stored on the stack**, not on the heap.
- **Each thread has its own call stack**, so local variables are naturally isolated.
- This isolation ensures **thread safety without synchronization**.
- The technique is formally known as **thread confinement**, and it's widely used in systems like connection pools.
- If a variable needs to **persist beyond a method** or be shared between threads, it must be stored in the **heap**—and then, synchronization becomes necessary.

#### Reflection

You might have heard that recursive methods can cause **stack overflow**. Why is that? Can you think of techniques to avoid it?

> Hint: Every method call adds a new frame to the stack. Too many calls without returning will exhaust the stack space.

Feel free to share your thoughts or explore more about **iterative vs recursive design** as a way to avoid stack overflows.


### 1.5 `wait()` vs `sleep()`: Understanding the Differences

In concurrent programming, it is often necessary to pause the execution of a thread, either to allow other threads to proceed or to wait for certain conditions to be met. In Java, two commonly used methods for pausing a thread are `sleep()` and `wait()`. Although both methods appear similar at first glance—since they both suspend a thread’s execution—they are fundamentally different in terms of purpose, behavior, and usage.

#### The `sleep()` Method

The `sleep()` method is a static method of the `Thread` class. It causes the currently executing thread to pause for a specified amount of time. Once the specified duration elapses, the thread becomes eligible to run again.

**Key Characteristics of `sleep()`:**

- It is defined in the `Thread` class and is declared as `static`, meaning it is called on the currently executing thread.
- It is typically used to delay execution deliberately, for example, to simulate a time-consuming task or to implement polling logic.
- It does not require the thread to hold any lock or be within a synchronized context.
- During the sleep period, if the thread holds a lock (such as from a `synchronized` block), it continues to hold that lock, potentially preventing other threads from making progress.
- The thread resumes automatically after the specified time period has passed, unless it is interrupted.
- If interrupted while sleeping, it throws an `InterruptedException`.

**Example:**
```java
Thread.sleep(1000); // Pause for 1 second
```

This line will suspend the currently executing thread for 1000 milliseconds.

#### The `wait()` Method

In contrast, `wait()` is an instance method defined in the `Object` class, and it plays a central role in Java's low-level inter-thread communication. It allows one thread to pause execution and release the monitor (lock) it holds, giving other threads an opportunity to perform work or change shared state.

**Key Characteristics of `wait()`:**

- It must be called from within a `synchronized` block or method. Otherwise, it will throw an `IllegalMonitorStateException`.
- When a thread calls `wait()`, it temporarily releases the lock it holds on the object and enters a waiting state.
- The thread remains in the waiting state until:
  - Another thread invokes `notify()` or `notifyAll()` on the same object.
  - The thread is interrupted.
  - If a timed version is used, the specified time elapses.
- It is designed for coordination between threads that share data and need to signal changes in state.

**Example:**
```java
synchronized (lockObject) {
    lockObject.wait(); // Releases lock and waits
}
```

In this scenario, the current thread waits until it is explicitly notified or interrupted.

#### Side-by-Side Comparison

| Feature                      | `sleep()`                              | `wait()`                                      |
|-----------------------------|-----------------------------------------|-----------------------------------------------|
| Defined in                  | `Thread` class                         | `Object` class                                 |
| Static or Instance          | Static                                  | Instance                                       |
| Requires a lock?            | No                                      | Yes (must be in synchronized context)          |
| Releases lock while waiting | No                                      | Yes                                            |
| Can be interrupted          | Yes (throws `InterruptedException`)     | Yes (throws `InterruptedException`)            |
| Wait duration               | Fixed duration                          | Indefinite or timed                            |
| Resumes when                | Time elapses or thread is interrupted   | Notified, interrupted, or timeout occurs       |
| Primary use case            | Delay execution                         | Inter-thread communication and synchronization |

#### Practical Implications

- Use `sleep()` when you want to pause execution regardless of shared resource availability or other thread activity. It is passive and time-based.
- Use `wait()` when you need a thread to pause execution **and** allow others to modify shared state or notify that work can resume. It is an active part of synchronized coordination.

#### Summary

While both `wait()` and `sleep()` suspend thread execution, they serve different purposes and have different effects on locks and synchronization. Choosing the correct method depends on the intended behavior:

- For time-based delays: use `sleep()`.
- For coordinated thread communication: use `wait()` in conjunction with `notify()` or `notifyAll()`.

Mastering these differences is essential for writing robust, concurrent Java applications.


### 1.6 Monitor: The Synchronized Block and Monitor Concept

In Java and many other object-oriented programming languages, a **monitor** is a fundamental concurrency control mechanism used to enforce **mutual exclusion** and ensure **thread safety** when accessing shared resources. A monitor guarantees that **only one thread at a time** can execute a block of code protected by it, thereby preventing race conditions and data inconsistency.

#### What Is a Monitor?

A **monitor** is an abstract object or construct that wraps shared data with operations and synchronizes access to them. In Java, every object implicitly serves as a monitor, thanks to its built-in support for multithreading via the `synchronized` keyword.

More formally:

A monitor is a synchronization mechanism that allows threads to have both **mutual exclusion** (only one thread can execute critical sections of code at a time) and the ability to **wait** (suspend execution) until a certain condition becomes true.

#### Mutual Exclusion with `synchronized`

Java uses the `synchronized` keyword to implement monitors. When a thread enters a `synchronized` block or method, it **acquires the object's intrinsic lock** (also known as a **monitor lock** or **mutex**). No other thread can enter any other synchronized block or method locked on the same object until the first thread exits and releases the lock.

**Examples:**

** Synchronized Method (using `this` as the monitor):**
```java
public synchronized void updateBalance() {
    // Only one thread at a time can execute this method
}
```

** Synchronized Block (explicitly specifying the monitor object):**
```java
public void updateBalance() {
    synchronized (this) {
        // Critical section
    }
}
```

In both cases, the monitor ensures that only one thread at a time executes the critical section, preventing concurrent access and potential data corruption.

#### Monitors and Intrinsic Locks

Every object in Java has an **intrinsic lock** (monitor lock). When a thread enters a `synchronized` method or block, it attempts to **acquire this lock**:

- If the lock is available, the thread enters and continues execution.
- If the lock is held by another thread, the calling thread is **blocked** until the lock is released.

Once the thread exits the synchronized block, it **automatically releases** the lock, allowing other waiting threads to proceed.

#### Relationship to `wait()`, `notify()`, and `notifyAll()`

Monitors not only provide mutual exclusion but also support **condition synchronization**, allowing threads to cooperate based on shared state. The `Object` class defines methods `wait()`, `notify()`, and `notifyAll()` that can be used only within a synchronized context.

For example:

```java
synchronized (lock) {
    while (!conditionIsMet) {
        lock.wait(); // releases the monitor and waits
    }
    // proceed once condition is true
}
```

These methods form the foundation of the **monitor wait-notify protocol**, where threads can wait on a condition and be notified when another thread changes the state.

#### Enforcement by Compiler and Runtime

Java enforces the monitor concept at both **compile time** and **runtime**:

- The compiler checks that `wait()`, `notify()`, and `notifyAll()` are called only within synchronized blocks.
- At runtime, the Java Virtual Machine (JVM) manages intrinsic locks to ensure proper synchronization and prevent illegal access.

Attempting to call `wait()` outside a synchronized block will result in an `IllegalMonitorStateException`, ensuring the correctness of the monitor protocol.

#### Summary

- A **monitor** is a synchronization mechanism that ensures only one thread can execute a critical section at a time.
- In Java, every object acts as a monitor and can be used with the `synchronized` keyword.
- Monitors enforce both **mutual exclusion** and **condition-based coordination** via intrinsic locks and methods like `wait()` and `notify()`.
- This model is simple to use but can lead to complexity in larger systems, which is why more advanced concurrency utilities (like `Lock`, `ReentrantLock`, and `Condition`) are often used in modern Java code.

Understanding monitors is foundational to writing correct and efficient multithreaded programs in Java.


### 1.7 User Threads vs Daemon Threads

In the Java concurrency model, all threads fall into one of two categories: **user threads** or **daemon threads**. Understanding the distinction between them is crucial for controlling the lifecycle and termination behavior of Java applications.

#### 1.7.1 What Are User Threads?

**User threads** are the primary threads that perform the main tasks of an application. These threads are created by the application itself—typically, any thread you instantiate and start is a user thread unless explicitly configured otherwise.

A key characteristic of user threads is that the **Java Virtual Machine (JVM) will continue running as long as at least one user thread is alive**. This means that even if the `main` method finishes execution, the JVM will not terminate if any user thread is still running in the background.

These threads are considered essential to the business logic of the application. Common examples include threads for processing user input, running computations, or handling server requests.

#### 1.7.2 What Are Daemon Threads?

**Daemon threads**, on the other hand, are background service threads that support user threads but are not considered essential for the application to continue running. These threads typically provide services like:

- Garbage collection
- Monitoring tasks
- Scheduled background maintenance

The defining behavior of a daemon thread is that **the JVM will terminate automatically once all user threads have finished, even if daemon threads are still running**. This allows JVM resources to be reclaimed without waiting for non-essential background tasks to complete.

Daemon threads are often used for tasks that can safely be abandoned when the program exits. However, since they may be terminated abruptly, they should not be used to perform critical operations or tasks that require guaranteed completion.

#### 1.7.3 How to Set a Daemon Thread

In Java, a thread can be designated as a daemon thread by calling the `setDaemon(true)` method **before** it is started. Once a thread has been started, attempting to set it as a daemon will throw an `IllegalThreadStateException`.

```java
Thread t1 = new Thread(() -> {
    System.out.println(Thread.currentThread().getName() + " is running as " +
        (Thread.currentThread().isDaemon() ? "a daemon thread" : "a user thread"));
    while (true) {
        // Simulate continuous background work
    }
}, "t1");

t1.setDaemon(true);  // Must be called before start()
t1.start();
```

#### 1.7.4 Example Demonstration

Here's a simple example to illustrate the behavior of a user thread:

```java
public class UserThreadDemo {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " :: Daemon? " + Thread.currentThread().isDaemon());
            while (true) {
                // Simulates a long-running user thread
            }
        }, "t1");

        t1.setDaemon(false);  // Marked as a user thread (default)
        t1.start();
        System.out.println(Thread.currentThread().getName() + " ends");
    }
}
```

**Expected Output:**

```
main ends
t1 :: Daemon? false
```

Even though the `main` method finishes, the program does not terminate because the `t1` user thread is still running.

Now compare with a daemon thread example:

```java
public class DaemonDemo {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " :: Daemon? " + 
                (Thread.currentThread().isDaemon() ? "Yes (daemon thread)" : "No (user thread)"));
            while (true) {
                // Simulate background work
            }
        }, "t1");

        t1.setDaemon(true); // Set as daemon
        t1.start();

        try {
            TimeUnit.SECONDS.sleep(3); // Give daemon thread time to run
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread ends.");
    }
}
```

**Expected Output:**

```
t1 :: Daemon? Yes (daemon thread)
Main thread ends.
```

In this case, once the main thread completes, the JVM will shut down automatically, and the daemon thread will be terminated.

#### 1.7.5 Key Points to Remember

- **JVM Exit Condition**: The JVM exits automatically when all **user threads** finish execution, regardless of whether daemon threads are still active.
- **Non-Critical Work**: Daemon threads are ideal for non-critical background tasks that do not require completion guarantees.
- **Setting Daemon Threads**: Always set a thread as a daemon **before** calling its `start()` method; otherwise, an exception will be thrown.
- **Behavioral Caution**: Since daemon threads may be stopped without notice, avoid performing file I/O, network communication, or critical cleanup tasks inside them.
Sure! Here's the revised and **expanded version**, split into **Chapter 1.7 and 1.8**, with smoother explanations, clearer transitions, and contextual framing to make the concepts more digestible, especially for those new to `Lock` and `synchronized`.

### 1.8 Multiple Ways to Create Threads


Java provides multiple ways to create and manage threads. Let's explore each method in detail with practical examples.

#### 1.8.1 Extending the `Thread` Class

This is the most basic way to create a thread, but it's less flexible due to Java's single inheritance limitation.

#### Example: Ticket Sales System

```java
public class TicketThread extends Thread {
    private int tickets = 100;
    
    @Override
    public void run() {
        while (tickets > 0) {
            System.out.println(Thread.currentThread().getName() + 
                " sells ticket #" + tickets--);
            try {
                // Simulate processing time
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        // Create two separate thread instances
        TicketThread thread1 = new TicketThread();
        TicketThread thread2 = new TicketThread();
        
        // Start the threads
        thread1.start();
        thread2.start();
        
        // Note: Each thread has its own ticket count (200 tickets total)
    }
}
```

**Key Points:**
- Each thread maintains its own `tickets` variable (no sharing)
- Simple to implement but limited by single inheritance
- Not suitable when threads need to share resources

#### 1.8.2 Implementing the `Runnable` Interface

This is the preferred approach as it allows your class to extend another class if needed.

#### Example: Shared Ticket Counter

```java
public class TicketRunnable implements Runnable {
    private int tickets = 100; // Shared by all threads
    
    @Override
    public void run() {
        while (tickets > 0) {
            System.out.println(Thread.currentThread().getName() + 
                " sells ticket #" + tickets--);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        TicketRunnable runnable = new TicketRunnable();
        
        // Create multiple threads sharing the same runnable
        Thread thread1 = new Thread(runnable, "Window 1");
        Thread thread2 = new Thread(runnable, "Window 2");
        Thread thread3 = new Thread(runnable, "Window 3");
        
        thread1.start();
        thread2.start();
        thread3.start();
        
        // Note: All threads share the same ticket count (100 tickets total)
    }
}
```

**Key Points:**
- Multiple threads share the same `Runnable` instance
- More flexible as the class can still extend another class
- Better for resource sharing between threads
- **Warning:** This example has a race condition (we'll fix it later with synchronization)

#### 1.8.3 Implementing the `Callable` Interface

`Callable` is similar to `Runnable` but can return a result and throw exceptions. It's used with the Executor framework.

#### Example: Parallel Computation with Results

```java
import java.util.concurrent.*;
import java.util.ArrayList;
import java.util.List;

public class PrimeCalculator implements Callable<List<Integer>> {
    private final int start;
    private final int end;
    
    public PrimeCalculator(int start, int end) {
        this.start = start;
        this.end = end;
    }
    
    @Override
    public List<Integer> call() throws Exception {
        List<Integer> primes = new ArrayList<>();
        for (int i = start; i <= end; i++) {
            if (isPrime(i)) {
                primes.add(i);
            }
        }
        return primes;
    }
    
    private boolean isPrime(int number) {
        if (number <= 1) return false;
        for (int i = 2; i <= Math.sqrt(number); i++) {
            if (number % i == 0) return false;
        }
        return true;
    }

    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Create tasks
        Callable<List<Integer>> task1 = new PrimeCalculator(1, 1000);
        Callable<List<Integer>> task2 = new PrimeCalculator(1001, 2000);
        Callable<List<Integer>> task3 = new PrimeCalculator(2001, 3000);
        
        // Submit tasks and get Futures
        Future<List<Integer>> future1 = executor.submit(task1);
        Future<List<Integer>> future2 = executor.submit(task2);
        Future<List<Integer>> future3 = executor.submit(task3);
        
        // Get results (this blocks until the computation is complete)
        List<Integer> primes1 = future1.get();
        List<Integer> primes2 = future2.get();
        List<Integer> primes3 = future3.get();
        
        // Combine results
        List<Integer> allPrimes = new ArrayList<>();
        allPrimes.addAll(primes1);
        allPrimes.addAll(primes2);
        allPrimes.addAll(primes3);
        
        System.out.println("Total primes found: " + allPrimes.size());
        
        executor.shutdown();
    }
}
```

**Key Points:**
- Can return a result (unlike `Runnable`)
- Can throw checked exceptions
- Used with `ExecutorService` for thread pool management
- `Future` objects allow you to retrieve results and check status

#### 1.8.4 Lambda Expressions

Lambda expressions provide a concise way to simplify thread creation.

#### Example: Lambda Threads

```java
public class LambdaThreads {
    public static void main(String[] args) {
        // Using Runnable with lambda
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("Lambda thread running: " + i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        // Using Callable with lambda and ExecutorService
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Integer> future = executor.submit(() -> {
            int sum = 0;
            for (int i = 1; i <= 100; i++) {
                sum += i;
            }
            return sum;
        });
        
        thread1.start();
        
        try {
            System.out.println("Sum from 1 to 100: " + future.get());
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```

**Key Points:**
- Concise syntax for simple thread tasks
- Can be used with both `Runnable` and `Callable`
- Particularly useful with Executor framework

#### Choosing the Right Approach

**Extend Thread**: Only if you need to override other Thread methods
**Implement Runnable**: Most common approach for basic threading
**Implement Callable**: When you need return values or exception handling
**Lambda Expressions**: For simple tasks where conciseness is preferred

Remember that for all shared resource scenarios (like the ticket example), proper synchronization is needed to prevent race conditions, which we'll cover when discussing `Lock` and other synchronization mechanisms.


### 1.9 Revisiting `synchronized` and the Birth of the Lock Interface

#### 1.9.1 Understanding `synchronized` in Java

The `synchronized` keyword is Java’s original solution for thread-safe operations. It can be used to mark **methods** or **blocks of code** that should only be accessed by one thread at a time.

#### Scope and Use

`synchronized` can be applied in three major ways:

- **Instance method**: Locks the object (`this`).
- **Static method**: Locks the class (`Class.class`).
- **Code block**: Locks a specific object provided in parentheses.

#### A Classic Example: Selling Tickets with `synchronized`

Let’s look at a common multithreading example — a ticket-selling system. Here's how it works using `synchronized`:

```java
class Ticket {
    private int rest = 1000;

    public synchronized void sale() {
        if (rest > 0)
            System.out.println(Thread.currentThread().getName() + " sold one ticket, remaining: " + --rest + " tickets;");
    }
}
```

And the test runner:

```java
public class SaleTicketTest {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        Runnable r = () -> {
            for (int i = 0; i < 1000; i++) {
                ticket.sale();
            }
        };

        new Thread(r, "A").start();
        new Thread(r, "B").start();
        new Thread(r, "C").start();
    }
}
```

Each thread calls the `sale()` method, and thanks to `synchronized`, ticket sales are thread-safe — only one thread can execute the method at a time.


#### 1.9.2 The Need for More Control: Enter the `Lock` Interface

While `synchronized` is easy to use, it's also somewhat limited. For example:

- What if you want to try locking but skip the operation if the lock isn’t immediately available?
- What if you need to **respond to thread interruption** while waiting for a lock?
- What if you want **multiple conditions** (e.g., producer-consumer scenarios)?

That’s where the **`Lock` interface** from `java.util.concurrent.locks` comes into play.

#### Key Features of `Lock` Implementations

- **Manual control over lock acquisition and release**
- **Try-locking** (`tryLock()`): attempt to acquire the lock without blocking
- **Interruptible locks** (`lockInterruptibly()`): can respond to interrupts
- **Timed locks** (`tryLock(long timeout, TimeUnit unit)`): attempt for a limited time
- **Condition support**: use `Condition` for more flexible waiting/notification

### 1.10 Leveraging the `Lock` Interface for Fine-Grained Control

#### 1.10.1 Ticket Selling with `ReentrantLock`

Let’s see how `ReentrantLock`, a popular implementation of the `Lock` interface, can be used in the same ticket-selling scenario:

```java
class Ticket {
    private int rest = 1000;
    private final ReentrantLock lock = new ReentrantLock();

    public void sale() {
        try {
            lock.lock();
            if (rest > 0)
                System.out.println(Thread.currentThread().getName() + " sold one ticket, remaining: " + --rest + " tickets;");
        } finally {
            lock.unlock(); // Always unlock in finally to avoid deadlock
        }
    }
}
```

Usage remains the same:

```java
public class LSaleTicketTest {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        Runnable r = () -> {
            for (int i = 0; i < 1000; i++) {
                ticket.sale();
            }
        };

        new Thread(r, "A").start();
        new Thread(r, "B").start();
        new Thread(r, "C").start();
    }
}
```

#### 1.10.2 `synchronized` vs. `Lock`: A Comparison

| Feature             | `synchronized`                        | `Lock`                             |
|---------------------|----------------------------------------|-------------------------------------|
| Type                | Language keyword                       | Java class (`ReentrantLock`, etc.) |
| Lock Release        | Automatic (at method/block end)        | Manual (`lock()` / `unlock()`)     |
| Interruptible Lock? | No                                     | Yes (`lockInterruptibly()`)        |
| Try Locking         | Not supported                          | Supported (`tryLock()`)            |
| Timeout Support     | Not supported                          | Yes (`tryLock(timeout)`)           |
| Condition Variables | `wait()/notify()` on intrinsic lock    | `Condition` objects supported      |
| Read Performance    | Lower in high-contention scenarios     | Higher with `ReadWriteLock`        |
| Lock Status         | Cannot detect lock status              | Can detect if lock was acquired successfully |
| Interruptibility    | Cannot be interrupted while waiting    | Can be interrupted while waiting   |
| Lock Release        | Automatically released at method/block end | Must be manually released (failure to unlock leads to deadlocks, so unlock should be in finally) |


#### 1.10.3 When to Use What?

| Scenario | Recommended |
|---------|-------------|
| Simple critical section | `synchronized` |
| Need for timeouts or interrupts | `Lock` |
| Complex concurrency with multiple wait conditions | `Lock` + `Condition` |
| Want less boilerplate and simplicity | `synchronized` |

In short, use `synchronized` for straightforward locking and `Lock` when you need more advanced or fine-grained control.
{pagebreak}

k}

