## Chapter 9 Advanced Concurrency with Compare-And-Swap 

### 9.1 The Evolution of Thread Safety Mechanisms

#### 9.1.1 Traditional Synchronization Approach (Pre-CAS)

**Implementation Characteristics:**
```java
public class Counter {
    private volatile int count = 0;
    
    public int getCount() {
        return count; // Volatile read for visibility
    }
    
    public synchronized void increment() {
        count++; // Lock-protected compound operation
    }
}
```

**Key Limitations:**
1. **Performance Overhead**:
   - Synchronization requires kernel-mode transitions
   - Creates contention points under high thread competition
   - Typical lock acquisition costs 50-100 CPU cycles

2. **Granularity Issues**:
   - Coarse-grained locking reduces parallelism
   - Blocks all threads even for independent operations
   - Can lead to convoy effect (threads queuing unnecessarily)

3. **Deadlock Risks**:
   - Potential for circular wait conditions
   - Requires careful lock ordering discipline
   - Difficult to debug in complex systems

**Memory Semantics:**
- Volatile ensures visibility but not atomicity
- Synchronized provides both but with higher overhead
- No optimal middle ground for simple operations

#### 9.1.2 Atomic Variable Revolution (CAS-Based)

**Modern Implementation:**
```java
public class AtomicCounter {
    private final AtomicInteger count = new AtomicInteger(0);
    
    public int getCount() {
        return count.get(); // No locking required
    }
    
    public void increment() {
        count.incrementAndGet(); // Lock-free atomic operation
    }
}
```

**CAS Mechanism Advantages:**
1. **Hardware Acceleration**:
   - Leverages CPU compare-and-swap instructions
   - Typically completes in 10-20 cycles
   - No OS-level context switching

2. **Fine-Grained Concurrency**:
   - Per-variable rather than per-critical-section
   - Allows true parallel operations
   - Scales linearly with core count

3. **Deadlock Immunity**:
   - No lock acquisition ordering required
   - No blocking of threads
   - Failure cases limited to retries

**Performance Comparison:**
| Operation | Synchronized | AtomicInteger |
|-----------|-------------|---------------|
| Read | ~5ns (volatile) | ~5ns |
| Write | ~50ns | ~15ns |
| Contended Write | ~100ns+ | ~30ns |
| Memory Footprint | 16-32 bytes | 16-32 bytes |

**Implementation Details:**
```java
// Simplified CAS pseudocode
public final int incrementAndGet() {
    int current;
    do {
        current = get(); // Volatile read
    } while (!compareAndSet(current, current + 1));
    return current + 1;
}
```

**Transition Impact:**
1. **Throughput Improvement**:
   - 3-5x better under moderate contention
   - 10x+ better under high contention

2. **Programming Model Shift**:
   - From pessimistic locking to optimistic concurrency
   - Requires understanding of CAS failure handling
   - Enables non-blocking algorithm designs

3. **JVM Integration**:
   - HotSpot provides intrinsic optimizations
   - Special handling for x86 LOCK CMPXCHG
   - Fallback to spin loops when contended
### 9.2 Understanding CAS (Compare-And-Swap) Mechanism

#### 9.2.1 Core Concept of CAS

**Definition and Components:**
CAS (Compare-And-Swap) is a fundamental atomic operation used in concurrent programming that involves three key parameters:
1. **Memory Location (V):** The address of the variable to be modified
2. **Expected Value (A):** The value the variable is presumed to have
3. **New Value (B):** The desired new value

**Operation Workflow:**
```pseudo
1. Compare V and A
2. If V == A:
   - Update V with B
   - Return success
3. If V != A:
   - Do nothing
   - Return failure
```

**Key Characteristics:**
- Atomic hardware operation
- Non-blocking behavior
- Optimistic concurrency approach
- No thread suspension/context switching

#### 9.2.2 Hardware-Level Implementation

**Processor Instruction Support:**
```assembly
; x86/64 implementation
LOCK CMPXCHG [mem], reg
; ARM implementation
LDREX/STREX
```

**Execution Guarantees:**
1. **Bus Locking:** For multi-core systems, temporarily locks memory bus
2. **Cache Coherence:** Ensures visibility across all cores
3. **Atomicity:** Complete operation executes as single unit

**Performance Advantages:**
| Metric | CAS | Synchronized |
|--------|-----|-------------|
| Throughput | High (10M ops/sec) | Medium (1M ops/sec) |
| Latency | 10-20 cycles | 50-100 cycles |
| Contention Handling | Exponential backoff | OS scheduling |

#### 9.2.3 Java Implementation Example

**AtomicInteger Usage:**
```java
public class CASDemo {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(5);
        
        // Successful CAS
        boolean success1 = counter.compareAndSet(5, 2020); 
        System.out.println(success1); // true
        
        // Failed CAS
        boolean success2 = counter.compareAndSet(5, 1024);
        System.out.println(success2); // false
    }
}
```

**Memory Layout:**
```
+-------------------+
| AtomicInteger     |
|-------------------|
| valueOffset: 0x10 |→ Points to value field
| value: 5          |
+-------------------+
```

#### 9.2.4 Deep Dive into compareAndSet

**Unsafe Class Interaction:**
```java
public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
```

**Parameter Breakdown:**
1. **this:** The AtomicInteger instance
2. **valueOffset:** Field memory offset (calculated via Unsafe)
3. **expect:** Expected current value
4. **update:** Desired new value

**Unsafe Class Role:**
- Provides low-level, native memory access
- Bypasses JVM safety checks (hence "unsafe")
- Direct hardware instruction mapping
- Used by all atomic classes internally

#### 9.2.5 CAS Failure Modes and Handling

**Common Scenarios:**
1. **False Failures:** Due to concurrent modification
2. **ABA Problem:** Value changes and returns to original
3. **Contention Issues:** High retry rates under load

**Optimization Techniques:**
1. **Exponential Backoff:** Progressive delays between retries
2. **Batch Processing:** Combine multiple operations
3. **Fallback Strategies:** Switch to locks under contention

#### 9.2.6 Limitations and Considerations

**ABA Problem Example:**
```
Thread 1: Reads value A
Thread 2: Changes A→B→A
Thread 1: CAS succeeds (sees A as expected)
```

**Solutions:**
- **Version Stamps:** AtomicStampedReference
- **Epoch Counters:** Incrementing modification counter

**Throughput Degradation:**
- Under high contention, CAS may perform worse than locks
- Requires careful capacity planning

### **9.3. CAS (Compare-And-Swap) Underlying Principles and the Role of the Unsafe Class**  

#### **9.3.1. The Role of the Unsafe Class**  
The `Unsafe` class in Java is a critical component that allows low-level memory manipulation, similar to pointer operations in C/C++. Since Java does not provide direct access to system-level resources, `Unsafe` acts as a "backdoor," enabling operations such as:  
- **Direct memory access** (reading/writing arbitrary memory addresses).  
- **Thread scheduling and synchronization**.  
- **Atomic operations via CAS (Compare-And-Swap)**.  

**Key Points:**  
1. **Bypassing JVM Safety Checks** – Unlike standard Java methods, `Unsafe` allows direct memory modification without security restrictions.  
2. **Foundation for Atomic Classes** – Classes like `AtomicInteger` rely on `Unsafe` to perform CAS-based atomic updates.  
3. **Native Methods** – All `Unsafe` methods are marked as `native`, meaning they delegate execution to OS/hardware instructions for maximum efficiency.  

#### **9.3.2. How CAS Works**  
CAS is a **lock-free synchronization mechanism** that ensures thread safety without traditional locks (e.g., `synchronized`). Its core logic involves:  
1. **Compare** – Check if the current value in memory matches the expected (old) value.  
2. **Swap** – If they match, update the value to the new one; otherwise, do nothing (or retry).  
3. **Atomicity Guarantee** – The entire operation is executed as a single, uninterruptible CPU instruction.  

**Example in Java (`AtomicInteger`):**  
- `getAndIncrement()` uses CAS + `volatile` to ensure atomic increments without locks.  
- **Workflow:**  
  1. **Thread A** reads `value = 3` (expected value).  
  2. **Thread B** succeeds in updating `value` from `3` → `4` via CAS.  
  3. **Thread A** retries after detecting the change (due to `volatile` visibility).  
  4. The process repeats until Thread A’s CAS succeeds.  

#### **9.3.3. CAS Implementation in Java**  
While CAS is conceptually simple, its implementation depends on:  
1. **Hardware Support** – Modern CPUs provide atomic instructions (e.g., `cmpxchg` on x86) to perform CAS in a single step.  
2. **JVM & OS Abstraction** – The `Unsafe` class delegates CAS operations to platform-specific native code.  
3. **Memory Barriers** – Ensures changes are visible across threads (via `volatile`).  

**Simplified Execution Flow:**  
1. **Java Code** calls `AtomicInteger.getAndIncrement()`.  
2. **Unsafe.compareAndSwapInt()** triggers a JVM-native method.  
3. **CPU Instruction** executes the atomic compare-and-swap.  
4. **Result** is returned to Java, either confirming success or prompting a retry.  

#### **9.3.4. Summary & Key Takeaways**  
1. **CAS Advantages:**  
   - **Lock-Free** – Avoids thread blocking, improving performance in high-contention scenarios.  
   - **Hardware-Optimized** – CPU-level atomicity ensures efficiency.  
2. **Limitations:**  
   - **ABA Problem** – A value may change and revert, causing false positives (solved via versioning, e.g., `AtomicStampedReference`).  
   - **Spin Contention** – Excessive retries under high contention can waste CPU cycles.  
3. **Use Cases:**  
   - Counters (`AtomicInteger`).  
   - Lock-free data structures (e.g., `ConcurrentHashMap`).  
   - Optimistic concurrency control.  

**Final Note:**  
CAS is the foundation of **non-blocking algorithms**, enabling high-performance thread-safe operations without traditional locks. The `Unsafe` class bridges Java to low-level hardware support, making it possible to leverage these optimizations while maintaining portability.

### **9.4 Atomic References**  

#### **9.4.1. Beyond AtomicInteger: Other Atomic Types**  
While `AtomicInteger` provides atomic operations for primitive integers, Java also supports atomic versions of other types, including:  
- **`AtomicLong`** – For atomic `long` operations.  
- **`AtomicBoolean`** – For atomic `boolean` updates.  
- **`AtomicReference<T>`** – For atomic operations on **custom objects** (e.g., `AtomicBook`, `AtomicOrder`).  

**Why Use Atomic References?**  
- **Thread-safe object updates** without explicit locks (`synchronized`).  
- **Optimistic locking** via CAS (Compare-And-Swap), avoiding blocking.  
- **Support for custom classes** (e.g., `User`, `Product`) in concurrent environments.  

#### **9.4.2. AtomicReference Example**  
The `AtomicReference<T>` class allows atomic updates to object references. Below is a practical demo:  

```java
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;
import java.util.concurrent.atomic.AtomicReference;

@Getter
@ToString
@AllArgsConstructor
class User {
    String userName;
    int age;
}

public class AtomicReferenceDemo {
    public static void main(String[] args) {
        User z3 = new User("z3", 24);
        User li4 = new User("li4", 26);

        AtomicReference<User> atomicUser = new AtomicReference<>();
        atomicUser.set(z3); // Initialize with user "z3"

        // Attempt to swap "z3" with "li4"
        System.out.println(
            atomicUser.compareAndSet(z3, li4) + "\t" + atomicUser.get()
        ); // Output: true    User(userName=li4, age=26)

        // Fails because current value is now "li4", not "z3"
        System.out.println(
            atomicUser.compareAndSet(z3, li4) + "\t" + atomicUser.get()
        ); // Output: false   User(userName=li4, age=26)
    }
}
```

**Key Observations:**  
1. **`compareAndSet(expectedValue, newValue)`**  
   - Succeeds if the current value matches `expectedValue` (atomically updates to `newValue`).  
   - Fails otherwise (no change occurs).  
2. **Thread Safety**  
   - Even if multiple threads try to modify `atomicUser`, only one will succeed at a time due to CAS.  
3. **Use Case**  
   - Updating shared objects (e.g., user sessions, configuration) without locks.  


### **Key Takeaways**  
1. **AtomicReference** enables **lock-free thread-safe updates** for custom objects.  
2. Works via **CAS (Compare-And-Swap)**, similar to `AtomicInteger`.  
3. **Ideal for:**  
   - Shared configuration objects.  
   - State management in concurrent systems.  
   - Optimistic concurrency control (retry on failure).  

**Example Extensions:**  
- `AtomicStampedReference` – Adds a version stamp to avoid the **ABA problem**.  
- `AtomicMarkableReference` – Uses a boolean flag for state tracking.  

By leveraging `AtomicReference`, developers can build **high-performance, non-blocking concurrent systems** without resorting to heavy synchronization mechanisms.

### **9.5 Spin Locks: Implementing CAS-Based Locking**  

#### **9.5.1 What is a Spin Lock?**  
A **spin lock** is a type of lock where a thread **actively polls (spins)** in a loop to acquire the lock instead of being blocked (e.g., via `wait()` or OS-level sleep).  

**Key Characteristics:**  
✔ **Non-Blocking Retry** – Threads repeatedly check lock availability using **CAS (Compare-And-Swap)**.  
✔ **Low Overhead for Short Contention** – Avoids expensive thread context switches.  
✔ **High CPU Usage** – Spinning consumes CPU cycles while waiting.  

**Trade-offs:**  
**Best for short critical sections** (where waiting is faster than blocking).  
**Inefficient for long waits** (wastes CPU resources).  

#### **9.5.2 Implementing a Spin Lock in Java**  
Below is a **CAS-based spin lock** using `AtomicReference<Thread>`:  

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class SpinLockDemo {
    // AtomicReference holds the current lock owner (Thread)
    AtomicReference<Thread> atomicReference = new AtomicReference<>();

    // Acquire the lock (spin until successful)
    public void myLock() {
        Thread currentThread = Thread.currentThread();
        System.out.println(currentThread.getName() + "\t tries to acquire lock");
        
        // Spin until CAS succeeds (lock is free)
        while (!atomicReference.compareAndSet(null, currentThread)) {
            // Optional: Add a short delay to reduce CPU usage (e.g., Thread.yield())
        }
    }

    // Release the lock
    public void myUnLock() {
        Thread currentThread = Thread.currentThread();
        // Only the lock owner can release it
        atomicReference.compareAndSet(currentThread, null);
        System.out.println(currentThread.getName() + "\t releases the lock");
    }

    public static void main(String[] args) {
        SpinLockDemo spinLock = new SpinLockDemo();

        // Thread A acquires the lock, holds for 5 secs, then releases
        new Thread(() -> {
            spinLock.myLock();
            try { TimeUnit.SECONDS.sleep(5); } 
            catch (InterruptedException e) { e.printStackTrace(); }
            spinLock.myUnLock();
        }, "A").start();

        // Ensure Thread A starts first
        try { TimeUnit.SECONDS.sleep(1); } 
        catch (InterruptedException e) { e.pe until lock is free
            spinLock.myUnLock();
        }, "B").start();
    }
}
```

**How It Works:**  
1. **Lock Acquisition (`myLock`)**  
   - Thread A calls `compareAndSet(null, currintStackTrace(); }

        // Thread B spins until Thread A releases the lock
        new Thread(() -> {
            spinLock.myLock();  // Spins herrentThread)` → **succeeds** (lock acquired).  
   - Thread B calls `compareAndSet(null, currentThread)` → **fails and spins** (lock held by A).  
2. **Lock Release (`myUnLock`)**  
   - Thread A sets `atomicReference` back to `null` → Thread B’s next CAS attempt succeeds.  

**Output Example:**  
```
A	 tries to acquire lock  
B	 tries to acquire lock  
A	 releases the lock  
B	 releases the lock  
```


### **Key Takeaways**  
1. **Spin Locks vs. Traditional Locks**  
   - Spin locks avoid **thread suspension/resumption** (good for short waits).  
   - Traditional locks (e.g., `synchronized`) are better for **long waits** (less CPU waste).  
2. **Use Cases**  
   - Low-latency systems (e.g., real-time trading).  
   - When lock contention is **brief and infrequent**.  
3. **Optimizations**  
   - **Exponential Backoff**: Increase delay between retries to reduce CPU load.  
   - **Thread.yield()**: Lets other threads run during spins.  

**Final Note:**  
Spin locks are a **powerful tool for lock-free concurrency** but should be used judiciously to avoid CPU starvation. The example above demonstrates how CAS enables efficient, non-blocking synchronization.

### **9.6 Limitations of CAS**  

#### **9.6.1 High CPU Usage Due to Spinning**  
When a thread fails to perform a CAS operation, it **retries in a loop** (spinlock behavior). While this avoids thread blocking, it can lead to:  
- **CPU resource waste** – Continuous spinning consumes CPU cycles.  
- **Performance degradation** – Under high contention, multiple threads spinning can overload the CPU.  

**Example Scenario:**  
```java
// Pseudocode: CAS retry loop in AtomicInteger.getAndIncrement()
do {
    expectedValue = getCurrentValue();
    newValue = expectedValue + 1;
} while (!compareAndSet(expectedValue, newValue));  // Keeps retrying on failure
```  
**Impact:**  
- If many threads compete for the same variable, CPU usage spikes.  
- **Solution:** Introduce **exponential backoff** or fallback to blocking locks after a threshold.  

#### **9.6.2 The ABA Problem**  

##### **What is the ABA Problem?**  
CAS checks if a value is **still the same** before updating, but it cannot detect if the value was **changed and then reverted** (A → B → A).  

**Example:**  
1. **Thread 1** reads value `A` from memory.  
2. **Thread 2** changes `A` → `B` → `A` (e.g., in a queue, an item is removed and reinserted).  
3. **Thread 1** performs CAS: It sees `A` (expected) and **incorrectly succeeds**, even though the state changed.  

**Real-World Analogy:**  
- You check your bank balance ($100), leave the page, and return later to see $100 again.  
- Unseen: Someone **withdrew $50** and **deposited $50** in between. Your CAS-based transfer would proceed, ignoring the intermediate change.  

##### **Solution: AtomicStampedReference**  
Java provides `AtomicStampedReference` to track **both value and version** (stamp).  

**ABA Demo Fix:**  
```java
AtomicStampedReference<Integer> ref = new AtomicStampedReference<>(100, 1);

// Thread 3: Simulates ABA (A→B→A)
ref.compareAndSet(100, 101, stamp, stamp + 1);  // Version increments
ref.compareAndSet(101, 100, stamp + 1, stamp + 2);

// Thread 4: Detects ABA using version
boolean success = ref.compareAndSet(
    100,  // Expected value
    2019, // New value
    initialStamp,  // Expected stamp (1)
    initialStamp + 1  // New stamp
); // Fails if stamp changed!
```  
**Key Points:**  
- **Versioning** ensures the value **hasn’t been modified** (even if it matches).  
- Alternative: `AtomicMarkableReference` uses a boolean flag instead of a stamp.  


### **Summary of CAS Drawbacks**  
| Issue | Description | Solution |  
|--------|-------------|----------|  
| **CPU Spinning** | Retry loops waste CPU under contention. | Backoff strategies, hybrid locks. |  
| **ABA Problem** | Undetectable intermediate changes. | `AtomicStampedReference`, versioning. |  

**Final Advice:**  
- Use CAS for **short, low-contention** operations (e.g., counters).  
- For complex scenarios, consider **versioned references** or locks.  

The ABA problem highlights why **CAS alone isn’t always sufficient**—version tracking adds critical safety for real-world applications.
{pagebreak}