## Chapter 16 The Virtual Thread Execution Model


### **16.1 Virtual Thread Execution**  

When a virtual thread executes, the Java Virtual Machine (JVM) scheduler assigns it to a platform thread—a process called **mounting**. The platform thread serves as the **carrier thread** for the virtual thread. After executing some code, the virtual thread may be **unmounted**, freeing the platform thread for other virtual threads.  

#### **Mounting and Unmounting**  
- Virtual threads are **automatically unmounted** when they perform blocking operations (e.g., I/O) or wait.  
- Once the blocking operation completes, the scheduler may reassign the virtual thread to a **different platform thread**.  
- These operations are **transparent** to application code:  
  - `Thread.currentThread()` returns the virtual thread, not the carrier thread.  
  - Stack traces and thread-local variables are **isolated** between virtual and carrier threads.  


### **16.2 Virtual Thread States**  

A virtual thread transitions through several states during its lifecycle. The table below summarizes these states:  

| **State**      | **Description** |
|---------------|----------------|
| `NEW`         | Initial state after creation. |
| `STARTED`     | Thread has been started. |
| `RUNNING`     | Currently executing. |
| `PARKING`     | Attempting to park (yield execution). |
| `PARKED`      | Successfully parked (unmounted). |
| `PINNED`      | Failed to park (still mounted). |
| `RUNNABLE`    | Ready to resume execution. |
| `YIELDING`    | Attempting to yield execution. |
| `TERMINATED`  | Execution completed. |

#### **State Transitions**  
The following diagram illustrates possible state changes:  

1. **Initialization**  
   - `NEW → STARTED` (via `Thread.start()`).  
   - `STARTED → RUNNING` (first execution).  
   - `STARTED → TERMINATED` (if start fails).  

2. **Execution Flow**  
   - `RUNNING → TERMINATED` (normal completion).  
   - `RUNNING → PARKING` (attempting to park).  
     - `PARKING → PARKED` (successful unmount).  
     - `PARKING → PINNED` (failed unmount, thread remains mounted).  
   - `RUNNING → YIELDING` (voluntarily yielding).  
     - `YIELDING → RUNNING` (yield failed).  
     - `YIELDING → PINNED` (yield succeeded).  

3. **Resumption**  
   - `PINNED → RUNNABLE` (unparked or interrupted).  
   - `PARKED → RUNNABLE` (unparked or interrupted).  
   - `RUNNABLE → RUNNING` (resumed execution).  

#### **Special States (PARKING, PARKED, PINNED, YIELDING)**  
These states are unique to virtual threads:  
- **PARKING**: The thread is attempting to yield execution (e.g., during blocking operations).  
- **PARKED**: Successfully unmounted; the carrier thread is free.  
- **PINNED**: Failed to unmount (e.g., due to synchronized blocks); the carrier thread remains occupied.  
- **YIELDING**: The thread voluntarily gives up execution (via `Thread.yield()`).  

### 16.1 Continuation Foundation

Virtual threads in Java represent a revolutionary step toward scalable concurrency. Introduced as part of Project Loom and standardized in JDK 21, virtual threads aim to decouple the concept of “thread” from the cost of a native OS thread. At the heart of this design is **the continuation-based model**, which allows the suspension and resumption of thread execution **without** holding on to an OS thread.


#### **Core Concept: Delimited Continuations**

A **Continuation** in Java is a low-level abstraction that captures a segment of control flow—essentially a pause-and-resume snapshot. They are:

- **Delimited**: They only capture a portion of the call stack rather than the entire program context.
- **One-shot**: Once a continuation is resumed and finishes, it cannot be resumed again.
- **Stackful**: Unlike coroutines in some languages, Java continuations preserve the full call stack, allowing suspension at arbitrary points within deep method calls.

#### **How it Works (Internals)**
Continuations are implemented with the help of a custom runtime feature that captures the state of the stack frames. In simplified pseudocode:

```java
public class Continuation {
    private final ContinuationScope scope;
    private final Runnable target;
    private StackChunk stack; // Captures execution stack
    
    public Continuation(ContinuationScope scope, Runnable target) {
        this.scope = scope;
        this.target = target;
        this.stack = new StackChunk();
    }

    public void run() {
        if (stack.isEmpty()) {
            target.run(); // Start execution
        } else {
            stack.reload(); // Resume from yield
        }
    }

    public static void yield(ContinuationScope scope) {
        StackChunk.saveCurrent(); // Save call stack at yield point
    }
}
```

> Think of `yield()` as a safe “pause” button, and `run()` as a “resume” or “start” button depending on whether this is the first time or a continuation.

#### **Lifecycle in Action:**

1. **First Run**: Executes from start until the first `yield`.
2. **Yield Point**: Stack is stored in a safe, GC-aware structure.
3. **Resumption**: `run()` reloads the stack and resumes from the saved point.
4. **Completion**: When the target `Runnable` finishes, the continuation is done.

> Note: Continuations are not exposed to end-users in public API—they are used internally by virtual threads.


### 16.2 Virtual Thread Continuation

#### **Why Specialize?**

The class `VThreadContinuation` extends the basic continuation to integrate with the `VirtualThread` lifecycle, embedding thread-aware behavior such as cleanup and pinning detection.

```java
final class VThreadContinuation extends Continuation {
    private final VirtualThread vthread;

    VThreadContinuation(VirtualThread vthread, Runnable task) {
        super(VTHREAD_SCOPE, () -> {
            try {
                task.run(); // User's logic
            } finally {
                vthread.terminate(); // Cleanup after execution
            }
        });
        this.vthread = vthread;
    }

    @Override
    protected void onPinned() {
        vthread.notifyPinned(); // VirtualThread reacts to pinning
    }
}
```

#### **What It Adds:**

- **Scope Binding**: Ensures all virtual threads operate under the same logical continuation scope (`VTHREAD_SCOPE`), enabling the runtime to manage them as a group.
- **Termination Hook**: Guarantees cleanup code (`finally`) runs when a virtual thread finishes, releasing stack, memory, and other resources.
- **Pinning Awareness**: Invoked when a thread enters a **synchronized** block, preventing unmounting. This is crucial for safety, as pinning ties a virtual thread to a physical carrier thread.


### 16.3 VirtualThread Class Structure

#### **The VirtualThread Itself**

The public-facing class `VirtualThread` extends `Thread` but manages its own lifecycle using continuations rather than native OS threads.

```java
public class VirtualThread extends Thread {
    private final Executor scheduler; // Executes continuation
    private final VThreadContinuation cont;
    private volatile CarrierThread carrier; // Current native thread

    VirtualThread(Executor scheduler, String name, Runnable task) {
        super(name);
        this.scheduler = scheduler;
        this.cont = new VThreadContinuation(this, task);
    }

    void mount() {
        this.carrier = currentCarrierThread(); // Native thread assigned
        cont.run(); // Start or resume
    }

    void unmount() {
        this.carrier = null; // Detach from native thread
        VThreadContinuation.yield(VTHREAD_SCOPE);
    }
}
```

#### **Execution Lifecycle Phases:**

| Phase            | Description                                                                 |
|------------------|-----------------------------------------------------------------------------|
| **Start**        | `VirtualThread.start()` schedules the `mount()` on the pool                 |
| **Execution**    | The continuation runs on a carrier thread, executing the user logic         |
| **Blocking Call**| If a blocking I/O call is hit, the thread **yields** and **unmounts**       |
| **Resumption**   | The scheduler later mounts the thread again on another (or same) carrier    |
| **Completion**   | When `Runnable` ends, stack is discarded, and thread is marked as finished  |

> This model allows the platform to reuse carrier threads, avoid wasting OS threads on blocking I/O, and scale to millions of concurrent threads.


### 16.4 Scheduling Mechanics

#### **Carrier Threads and ForkJoinPool**

Virtual threads don't run directly on OS threads—they're scheduled **on demand** via a carrier thread pool. By default, this pool is a `ForkJoinPool`, but you can customize it.

```java
final class VirtualThreadScheduler {
    private static final ForkJoinPool DEFAULT_SCHEDULER =
        new ForkJoinPool(
            Runtime.getRuntime().availableProcessors(),
            pool -> {
                ForkJoinWorkerThread worker = new CarrierThread(pool);
                worker.setName("VT-Carrier-" + worker.getPoolIndex());
                return worker;
            },
            null,
            true // Async mode
        );
}
```

#### **Key Scheduler Behaviors:**

- **Work-Stealing**: Efficient load balancing across available carrier threads.
- **Pinning Awareness**: If a virtual thread is pinned, it's allowed to run uninterruptedly on its current carrier to avoid corruption.
- **Automatic Yield Points**: Inserted during blocking operations, enabling safe suspension.
- **Cooperative Multitasking**: Instead of preemption (as in OS threads), continuations cooperate by yielding on blocking calls (e.g., file I/O, socket read).


### 16.5 Optimization Summary

| Scenario           | Runtime Behavior                                 | JVM Optimization                             |
|--------------------|--------------------------------------------------|----------------------------------------------|
| Simple Execution   | Runs on carrier thread directly                  | No stack copying needed                      |
| I/O Blocking       | Stack copied, carrier thread released            | Allows reuse of carrier for other threads    |
| Pinned Execution   | Continuation sticks to carrier until done        | Avoids unsafe stack migration                |
| Thread Completion  | Stack memory released, GC can reclaim memory     | Memory efficient, especially for short-lived |


### Summary

Virtual threads provide a **lightweight, memory-efficient, and scalable** threading abstraction by leveraging:

- **Continuations** to enable cheap suspension/resumption
- **Carrier threads** for flexible, pooled execution
- **Yield-on-blocking** behavior to avoid holding OS resources
- **Compatibility** with `Thread`, `Runnable`, and standard APIs

This model enables **millions of concurrent threads** on a single JVM process—making structured concurrency, reactive-style performance, and imperative coding styles possible at the same time.


16.1 Virtual Threads vs. Platform Threads: Key Differences

Thread lifecycle comparison

Memory and scheduling overhead

16.2 The Carrier Thread Mechanism

Role of ForkJoinPool as the default scheduler

How platform threads execute virtual threads

Stack management (heap ↔ stack copying)

16.3 Cooperative Scheduling in Action

Non-preemptive scheduling rules

Yielding behavior during I/O and blocking operations

Debugging with thread dumps and JFR events

16.4 Thread Pinning and Its Implications

When virtual threads pin to carriers (synchronized blocks, JNI)

Mitigation strategies (replacing synchronized with ReentrantLock)

16.5 Scheduler Tuning and Configuration

Adjusting parallelism (jdk.virtualThreadScheduler.parallelism)

Custom scheduler implementations

Benchmarking carrier thread utilization
{pagebreak}